(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{580:function(e,t,i){"use strict";i.r(t),t.default=[{title:"207.Course Schedule_拓扑排序+图dfs",path:"/posts/207.%20Course%20Schedule_%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F+%E5%9B%BEdfs.html",strippedContent:" ##207.Course Schedule_拓扑排序+图dfs  Medium  There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses-1`.  Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: `[0,1]`  Given the total number of courses and a list of prerequisite **pairs**, is it possible for you to finish all courses?     **Example 1:**  ``` Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0. So it is possible. ```  **Example 2:**  ``` Input: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take.               To take course 1 you should have finished course 0, and to take course 0 you should              also have finished course 1. So it is impossible. ```     **Constraints:**  - The input prerequisites is a graph represented by **a list of edges**, not adjacency matrices. Read more about [how a graph is represented](https://www.khanacademy.org/computing/computer-science/algorithms/graph-representation/a/representing-graphs). - You may assume that there are no duplicate edges in the input prerequisites. - `1 <= numCourses <= 10^5`    ```cpp class Solution { public:     bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {         graph_ = vector<vector<int>>(numCourses);  //构造图彾接矩阵          for(const auto& p:prerequisites){             graph_[p[1]].push_back(p[0]);         }         vector<int> v(numCourses, 0);         for(int i=0;i<numCourses;i++){             if (dfs(i,v)) return false;         }         return true;     } private:     vector<vector<int>> graph_;     bool dfs(const int cur,vector<int>& v){         //这里v[cur] state ==0 指未访问； state == 1, visiting ; state == 2, visited;         if(v[cur]==1) return true;    // 若visiting， 那么说明该图形成环了，则不可能;         if (v[cur] ==2) return false; // 若visited， 那么说明他是以前访问过的 那就OK，接着访问下一个;                  v[cur] =1; //开启该节点正在访问状态                  for(const int t:graph_[cur])             if (dfs(t,v)) return false;                  v[cur] = 2; //标记该节点访问结束                    return false;     } }; ```    这个题的输入注意，不是vector<vector<int,int> ,而是 vector<vector<int>> , 所以在处理时用的是p[1]和p[0],而不是.first .second;  本题是一个 拓扑排序 **Topological Sort** ，核心在于图节点的dfs访问 ，以及三种状告的标识 ，经典算法;"},{title:"56. Merge Intervals",path:"/posts/56.%20Merge%20Intervals.html",strippedContent:" ##56. Merge Intervals  Medium  Given a collection of intervals, merge all overlapping intervals.  **Example 1:**  ``` Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. ```  **Example 2:**  ``` Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. ```  **NOTE:** input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.     **Constraints:**  - `intervals[i][0] <= intervals[i][1]`    这个是开始写的怎么都调不对的代码：  ```cpp class Solution { public:     vector<vector<int>> merge(vector<vector<int>>& intervals) {         vector<vector<int>> result;         sort(intervals.begin(),intervals.end(),[](vector<int> a,vector<int> b){             return (a[0]<b[0] || a[0]==b[0] && a[1]<=b[1]);         });         int flag = 0;           if (intervals.size()==1){             result = intervals;                      }         else{             for(int i=0;i<intervals.size();i++){             if(i==intervals.size()-1){                 if(!flag)                     result.push_back(intervals[i]);             }             else{                  if(intervals[i][1]>=intervals[i+1][0]){                                     result.push_back({intervals[i][0],intervals[i+1][1]});                     i++;                     if(i==intervals.size()-2){                         flag = 1;                     }             }             else{                 result.push_back(intervals[i]);             }             }         }          }         return result;     } }; ```  问题的原因在于没有用back()函数，直接读取vector<int> ans中最后一个元素进行比较，这样就能避免两个两个配对比较的index对不齐的坑跌状况;  ```c++ class Solution { public:     vector<vector<int>> merge(vector<vector<int>>& intervals) {         if (intervals.empty()) return {};                  std::sort(intervals.begin(), intervals.end(),                    [](const vector<int> a, const vector<int> b){                         return a[0] < b[0];                     });                  vector<vector<int>> ans;                 for (const auto& interval : intervals) {             if (ans.empty() || interval[0] > ans.back()[1]) {                 ans.push_back(interval);             } else {                 ans.back()[1] = max(ans.back()[1], interval[1]);             }         }         return ans;     } };  ```  这里面 用for (const auto& interval : intervals) ，值得学习;  ans.back()可以直接拿来比较，这样也不会出现没有比较遗漏element的状况。"},{title:"134. Gas Station",path:"/posts/134.%20Gas%20Station.html",strippedContent:" ##134. Gas Station  Medium  There are *N* gas stations along a circular route, where the amount of gas at station *i* is `gas[i]`.  You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from station *i* to its next station (*i*+1). You begin the journey with an empty tank at one of the gas stations.  Return the starting gas station's index if you can travel around the  circuit once in the clockwise direction, otherwise return -1.  **Note:**  - If there exists a solution, it is guaranteed to be unique. - Both input arrays are non-empty and have the same length. - Each element in the input arrays is a non-negative integer.  **Example 1:**  ``` Input:  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]  Output: 3  Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. ```  **Example 2:**  ``` Input:  gas  = [2,3,4] cost = [3,4,3]  Output: -1  Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. ```      ```cpp class Solution { public:     int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {                  int rest = 0;         int n = gas.size();         int p = 0;         int q = 1;         int flag = 0;         for (int j=0;j<n;j++){             gas.push_back(gas[j]);             cost.push_back(cost[j]);         }         int d = gas.size();         for (int i= 0; i<d;i++){                          if (gas[i]+rest-cost[i]>=0){                 rest += gas[i]-cost[i];                 q++;                 if(q==n+1){                     p = i;                     //q = m;                     flag = 1;                     break;                    }                                         }              else{                 q = 1;                 rest = 0;             }         }         if (flag)             return p-q+2;         else return -1;              } }; ```      把数组拓展去做;"},{title:"Minimum Height Trees",path:"/posts/310.%20Minimum%20Height%20Trees.html",strippedContent:" ##310. Minimum Height Trees  Medium  A tree is an undirected graph in which any two vertices are connected by *exactly* one path. In other words, any connected graph without simple cycles is a tree.  Given a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).  Return *a list of all **MHTs'** root labels*. You can return the answer in **any order**.  The **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.     **Example 1:**  ![img](https://assets.leetcode.com/uploads/2020/09/01/e1.jpg)  ``` Input: n = 4, edges = [[1,0],[1,2],[1,3]] Output: [1] Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT. ```  **Example 2:**  ![img](https://assets.leetcode.com/uploads/2020/09/01/e2.jpg)  ``` Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] Output: [3,4] ```  **Example 3:**  ``` Input: n = 1, edges = [] Output: [0] ```  **Example 4:**  ``` Input: n = 2, edges = [[0,1]] Output: [0,1] ```     **Constraints:**  - `1 <= n <= 2 * 104` - `edges.length == n - 1` - `0 <= ai, bi < n` - `ai != bi` - All the pairs `(ai, bi)` are distinct. - The given input is **guaranteed** to be a tree and there will be **no repeated** edges.  ```cpp class Solution { public:     vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {         unordered_map<int,unordered_set<int>> Map;         for (auto edge: edges){             int a = edge[0] , b =edge[1];             Map[a].insert(b);             Map[b].insert(a);                      } //将端点都添加到无序图；                  queue<int> q;         for(int i=0; i<n; i++){             if(Map[i].size() ==1)                 q.push(i);         }//将只有一个节点相邻的加入队列；                  unordered_set<int> Set;         for(int i=0; i<n; i++)             Set.insert(i);//把1-n加入set；                  while (Set.size()>2)//终止条件是Set的长度，即最中间的那两个节点；         {             int len = q.size();//循环长度是队列长度；             for (int k=0; k<len; k++){                 int cur =q.front();                 q.pop();                 Set.erase(cur);//从set中去掉该节点；                                  for (auto next: Map[cur]){                     Map[next].erase(cur);//从无序图中去掉该节点；                     if(Map[next].size() ==1) //如果该图长度为1,即无相邻节点                         q.push(next);//就把他加入队列；                 }                              }         }           vector<int> results(Set.begin(),Set.end());//results存的是set剩下来的；         return results;              } }; ```  "},{title:"142. Linked List Cycle II",path:"/posts/142.%20Linked%20List%20Cycle%20II.html",strippedContent:" ##142. Linked List Cycle II  Medium  Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.  There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.  **Notice** that you **should not modify** the linked list.  **Follow up:**  Can you solve it using `O(1)` (i.e. constant) memory?     **Example 1:**  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)  ``` Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. ```  **Example 2:**  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)  ``` Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. ```  **Example 3:**  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)  ``` Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. ```     **Constraints:**  - The number of the nodes in the list is in the range `[0, 104]`. - `-105 <= Node.val <= 105` - `pos` is `-1` or a **valid index** in the linked-list.    ```cpp /**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     ListNode *next;  *     ListNode(int x) : val(x), next(NULL) {}  * };  */ class Solution { public:     ListNode *detectCycle(ListNode *head)      {         if(head==NULL) return NULL;         ListNode* slow = head;         ListNode* fast = head;         bool ret=false;         while(fast->next!=NULL)         {             fast = fast->next;             slow = slow->next;             if(fast->next==NULL) return NULL; //判断这里有没有空指针指针，因为slow比fast慢，所以在后面走fast走过的路径，不用检测；             fast = fast->next;             if(fast==slow) //这里两指针相遇了；             {                 ret = true; //标志位置1；                 break;              }         }         if(ret==false) return NULL;          slow = head; //重置慢指针到头结点；         while(slow!=fast)         {             slow = slow->next;             fast = fast->next;         }         return slow;     } }; ```    这道题目是经典的快慢指针问题，也叫做Floy's algorithm。   思想是： 快指针是慢指针速度的两倍，同时开始，直到相遇；此时，慢指针重置到开头，快指针从相遇处继续，让快指针变成和慢指针一样的速度，那么他们再次相遇的地方就是环的起点。    ![image-20200928171402861](/home/viktor/.config/Typora/typora-user-images/image-20200928171402861.png)  "},{title:"57. Insert Interval",path:"/posts/57.%20Insert%20Interval.html",strippedContent:" ##57. Insert Interval  Medium  Given a set of *non-overlapping* intervals, insert a new interval into the intervals (merge if necessary).  You may assume that the intervals were initially sorted according to their start times.     **Example 1:**  ``` Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] ```  **Example 2:**  ``` Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. ```  **Example 3:**  ``` Input: intervals = [], newInterval = [5,7] Output: [[5,7]] ```  **Example 4:**  ``` Input: intervals = [[1,5]], newInterval = [2,3] Output: [[1,5]] ```  **Example 5:**  ``` Input: intervals = [[1,5]], newInterval = [2,7] Output: [[1,7]] ```     **Constraints:**  - `0 <= intervals.length <= 104` - `intervals[i].length == 2` - `0 <= intervals[i][0] <= intervals[i][1] <= 105` - `intervals` is sorted by `intervals[i][0]` in **ascending** order. - `newInterval.length == 2` - `0 <= newInterval[0] <= newInterval[1] <= 105`    ```cpp class Solution { public:     vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {             auto it = intervals.begin();         while (it != intervals.end() && newInterval[0] > (*it)[0]) ++it;//这里一定要注意，×it传的是值，对他索引时要带括号;         intervals.insert(it, newInterval);                  // Merge intervals without sorting         vector<vector<int>> ans;                 for (const auto& interval : intervals) {             if (ans.empty() || interval[0] > ans.back()[1]) {                 ans.push_back(interval);             } else {                 ans.back()[1] = max(ans.back()[1], interval[1]);             }         }                  return ans;     } };  ```    这个题主要是对于iterator的用法，   while (it != intervals.end() && newInterval[0] > (*it)[0]) ++it; 这句话写的 1.遍历 2.找到合适位置停下  然后insert， 没毛病;  这个题insert的newInterval就一个，所以就这么写了，没问题;    I'm sure you know that a `std::vector<X>` stores a whole bunch of `X` objects, right? But if you have a `std::map<X, Y>`, what it actually stores is a whole bunch of `std::pair<const X, Y>`s. That's exactly what a map is - it pairs together the keys and the associated values.  When you iterate over a `std::map`, you're iterating over all of these `std::pair`s. When you dereference one of these iterators, you get a `std::pair` containing the key and its associated value.  这里意思是如果是map，或者std::pair, 他们是可以（×it）.first .second 这样索引的，而这里没有，这里只有二维数组，所以只能直接index。  std::map<X, Y>实际储存了一串std::pair<const X, Y>  std::map<std::string, int> m = /* fill it */;  auto it = m.begin();  这里，如果你用*it，那么你将得到map第一个元素的std::pair：  现在你可以接收std::pair的两个元素：  (*it).first会得到key，  (*it).second会得到value。  这等同于it->first和it->second。"},{title:"84. 柱状图中最大的矩形",path:"/posts/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2_%E5%A0%86%E6%A0%88.html",strippedContent:" ## [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)  给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。  求在该柱状图中，能够勾勒出来的矩形的最大面积。     ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)  以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。     ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)  图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。     **示例:**  ``` 输入: [2,1,5,6,2,3] 输出: 10 ```      ```cpp class Solution { public:     int largestRectangleArea(vector<int>& heights) {            int ans = 0;     vector<int> st;     heights.insert(heights.begin(), 0);     heights.push_back(0);     for (int i = 0; i < heights.size(); i++)     {         while (!st.empty() && heights[st.back()] > heights[i])         {             int cur = st.back();             st.pop_back();             int left = st.back() + 1;             int right = i - 1;             ans = max(ans, (right - left + 1) * heights[cur]);         }         st.push_back(i);     }     return ans;              } }; ```    这个题关键在于堆栈的使用，在用堆栈前，对数据进行了前后补零处理。    ``` 堆栈模板： for (int i = 0; i < heights.size(); i++)     {         while (!st.empty() && heights[st.back()] > heights[i])         {         st.pop_back()；         }                  st.push_back(i); ```  "},{title:"89. Gray Code",path:"/posts/89.%20Gray%20Code_%E4%BD%8D%E6%93%8D%E4%BD%9C.html",strippedContent:" ##89. Gray Code  Medium  The gray code is a binary numeral system where two successive values differ in only one bit.  Given a non-negative integer *n* representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.  **Example 1:**  ``` Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2  For a given n, a gray code sequence may not be uniquely defined. For example, [0,2,3,1] is also a valid gray code sequence.  00 - 0 10 - 2 11 - 3 01 - 1 ```  **Example 2:**  ``` Input: 0 Output: [0] Explanation: We define the gray code sequence to begin with 0.              A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.              Therefore, for n = 0 the gray code sequence is [0]. ```      ```cpp class Solution { public: // iterative     vector<int> grayCode(int n) {         vector<int> vec{0};         for(int i = 0; i < n; ++i){             int tmp = 1 << i;   //位操作之向左移位;             for(int j = vec.size() - 1; j >= 0; --j){                 vec.push_back(vec[j] + tmp);  //tmp每次移动后的那个数，加上vec数组之前存的，相当于二进制数 后面的位置都循环加了一遍， 没有遗漏。             }         }         return vec;     } }; ```  当n = 4 时：  ```c++  result is: 0 result is: 1 result is: 3 result is: 2 result is: 6 result is: 7 result is: 5 result is: 4 result is: 12 result is: 13 result is: 15 result is: 14 result is: 10 result is: 11 result is: 9 result is: 8 ```    "}]}}]);