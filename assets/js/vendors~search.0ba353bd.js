(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{580:function(t,e,i){"use strict";i.r(e),e.default=[{title:"10. 正则表达式匹配",path:"/posts/10.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.html",strippedContent:" /#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)  给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。  - `'.'` 匹配任意单个字符 - `'*'` 匹配零个或多个前面的那一个元素  所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。  **示例 1：**  ``` 输入：s = \"aa\" p = \"a\" 输出：false 解释：\"a\" 无法匹配 \"aa\" 整个字符串。 ```  **示例 2:**  ``` 输入：s = \"aa\" p = \"a*\" 输出：true 解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 ```  **示例 3：**  ``` 输入：s = \"ab\" p = \".*\" 输出：true 解释：\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 ```  **示例 4：**  ``` 输入：s = \"aab\" p = \"c*a*b\" 输出：true 解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 ```  **示例 5：**  ``` 输入：s = \"mississippi\" p = \"mis*is*p*.\" 输出：false ```     **提示：**  - `0 <= s.length <= 20` - `0 <= p.length <= 30` - `s` 可能为空，且只包含从 `a-z` 的小写字母。 - `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。 - 保证每次出现字符 `*` 时，前面都匹配到有效的字符  ```cpp class Solution { public:     bool isMatch(string s, string p) {         return match(s.data(), p.data());     }     bool match(char* s, char* p) {         if (!*p) return !*s;//如果p光了，s也光了，那么就返回true； 否则就返回false；  这个返回的判断非常巧         if (*(p + 1) != '*') //判断p后一位是不是‘*’             return *s == *p || (*p == '.' && *s != '\\0') ? match(s + 1, p + 1) : false; //不是的话看第一位匹配不，匹配就去配第二位，不匹配return false；         else              return *s == *p || (*p == '.' && *s != '\\0') ? match(s, p + 2) || match(s + 1, p) : match(s, p + 2);//是的话，看第一位匹配不，匹配的话继续看s第一位和p第三位匹配不 以及 s第二位和p第一位匹配不， 如果第一位不匹配，那么只能s去配p的第二位。                      //或者return (*s == *p || (*p == '.' && *s != '\\0')) && match(s + 1, p) || match(s, p + 2);     } };  ```  用递归，同时考虑了好几种情况 。"},{title:"1002. 查找常用字符",path:"/posts/1002.%20%E6%9F%A5%E6%89%BE%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6.html",strippedContent:' #### [1002. 查找常用字符](https://leetcode-cn.com/problems/find-common-characters/)  给定仅有小写字母组成的字符串数组 `A`，返回列表中的每个字符串中都显示的全部字符（**包括重复字符**）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。  你可以按任意顺序返回答案。     **示例 1：**  ``` 输入：["bella","label","roller"] 输出：["e","l","l"] ```  **示例 2：**  ``` 输入：["cool","lock","cook"] 输出：["c","o"] ```     **提示：**  1. `1 <= A.length <= 100` 2. `1 <= A[i].length <= 100` 3. `A[i][j]` 是小写字母  ```cpp class Solution { public:     vector<string> commonChars(vector<string>& A) {         if (A.size() == 0)             return vector<string>();         unordered_map<char, int> ansMap;         unordered_map<char, int> midMap;         vector<string> ans;         for(auto c : A[0]) {             ansMap[c]++;         }         for (auto i = 1; i < A.size() ; ++i) {             midMap.clear();             for (auto c : A[i]) {                 midMap[c]++;             }             if (ansMap.size() == 0) {                 return ans;             }             for (auto iter = ansMap.begin(); iter != ansMap.end(); ) {                 if (midMap.count(iter->first)) {                      ansMap[iter->first] = min(ansMap[iter->first], midMap[iter->first]);                     iter++;  //这里需要注意，因为erase要删除当前的iter， 所以在这里iter++                 }                 else {                     iter = ansMap.erase(iter);                 }             }         }         for (auto iter = ansMap.begin(); iter != ansMap.end(); iter++) {             for (auto i = 0; i < ansMap[iter->first]; ++i) {                 ans.push_back(string(1, iter->first)); //这里关键是需要有几个字符就输出几个，所以string（1，*）             }         }         return ans;     } }; ```    先把第一个字符串写入ansMap， 然后把后面的一次写实midMap， 然后遍历ansMap看 midMap里有没有， 有的话就取二者小的；没有的话就从ansMap里删掉这个字符。最后需要注意返回的 有几个字符就输出几个，用string（1，*）'},{title:"1022. 从根到叶的二进制数之和",path:"/posts/1022.%20%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C.html",strippedContent:" #### [1022. 从根到叶的二进制数之和](https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers/)  给出一棵二叉树，其上每个结点的值都是 `0` 或 `1` 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 `0 -> 1 -> 1 -> 0 -> 1`，那么它表示二进制数 `01101`，也就是 `13` 。  对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。  以 **`10^9 + 7`** 为**模**，返回这些数字之和。     **示例：**  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/04/05/sum-of-root-to-leaf-binary-numbers.png)  ``` 输入：[1,0,1,0,1,0,1] 输出：22 解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 ```     **提示：**  1. 树中的结点数介于 `1` 和 `1000` 之间。 2. node.val 为 `0` 或 `1` 。    ```cpp class Solution {      int sum = 0; public:     int sumRootToLeaf(TreeNode* root) {         rootToLeaf(root,0);                  return sum;              }      void rootToLeaf(TreeNode* root,int cur){         if(!root->left && !root->right){             sum += (cur<<1) +root->val;             cout<<sum<<endl;             return;          }         cur = (cur<<1)+root->val;         if (root->left)             rootToLeaf(root->left,cur);         if (root->right)             rootToLeaf(root->right,cur);               } }; ```    记得cur<<1 要打括号，precedence里 + 比 cur 要高；  https://en.cppreference.com/w/cpp/language/operator_precedence"},{title:"1030. 距离顺序排列矩阵单元格",path:"/posts/1030.%20%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC.html",strippedContent:" #### [1030. 距离顺序排列矩阵单元格](https://leetcode-cn.com/problems/matrix-cells-in-distance-order/)  给出 `R` 行 `C` 列的矩阵，其中的单元格的整数坐标为 `(r, c)`，满足 `0 <= r < R` 且 `0 <= c < C`。  另外，我们在该矩阵中给出了一个坐标为 `(r0, c0)` 的单元格。  返回矩阵中的所有单元格的坐标，并按到 `(r0, c0)` 的距离从最小到最大的顺序排，其中，两单元格`(r1, c1)` 和 `(r2, c2)` 之间的距离是曼哈顿距离，`|r1 - r2| + |c1 - c2|`。（你可以按任何满足此条件的顺序返回答案。）     **示例 1：**  ``` 输入：R = 1, C = 2, r0 = 0, c0 = 0 输出：[[0,0],[0,1]] 解释：从 (r0, c0) 到其他单元格的距离为：[0,1] ```  **示例 2：**  ``` 输入：R = 2, C = 2, r0 = 0, c0 = 1 输出：[[0,1],[0,0],[1,1],[1,0]] 解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2] [[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。 ```  **示例 3：**  ``` 输入：R = 2, C = 3, r0 = 1, c0 = 2 输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]] 解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3] 其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。 ```     **提示：**  1. `1 <= R <= 100` 2. `1 <= C <= 100` 3. `0 <= r0 < R` 4. `0 <= c0 < C`    ```cpp class Solution { public:   vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0) {     vector<vector<int>> ans;     for (int i = 0; i < R; ++i)       for (int j = 0; j < C; ++j)         ans.push_back({i, j});     std::sort(begin(ans), end(ans), [r0, c0](const vector<int>& a, const vector<int>& b){       return (abs(a[0] - r0) + abs(a[1] - c0)) < (abs(b[0] - r0) + abs(b[1] - c0));     });     return ans;   } }; ```    究竟能不能 写成cmp function？ 是不是要用templae？？  怎么把 r0 ,c0 传进去？？？    ```cpp class Solution {     struct compare {     bool operator()(const vector<int> &a,const vector<int> &b) const {         return (abs(a[0]-r0)+abs(a[1]-c0))<(abs(b[0]-r0)+abs(b[1]-c0));     } };       public:     vector<vector<int>> allCellsDistOrder(int R, int C, int r0, int c0) {         vector<vector<int>> ans;         for(int i=0;i<R;i++)             for(int j=0;j<C;j++){                 ans.push_back({i,j});             }          sort(ans.begin(),ans.end(),compare());          return ans;      } };   ```  "},{title:"1036. 逃离大迷宫",path:"/posts/1036.%20%E9%80%83%E7%A6%BB%E5%A4%A7%E8%BF%B7%E5%AE%AB.html",strippedContent:" #### [1036. 逃离大迷宫](https://leetcode-cn.com/problems/escape-a-large-maze/)  在一个 10^6 x 10^6 的网格中，每个网格块的坐标为 `(x, y)`，其中 `0 <= x, y < 10^6`。  我们从源方格 `source` 开始出发，意图赶往目标方格 `target`。每次移动，我们都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表 `blocked` 上。  只有在可以通过一系列的移动到达目标方格时才返回 `true`。否则，返回 `false`。     **示例 1：**  ``` 输入：blocked = [[0,1],[1,0]], source = [0,0], target = [0,2] 输出：false 解释： 从源方格无法到达目标方格，因为我们无法在网格中移动。 ```  **示例 2：**  ``` 输入：blocked = [], source = [0,0], target = [999999,999999] 输出：true 解释： 因为没有方格被封锁，所以一定可以到达目标方格。 ```    ```cpp class Solution { private:     int length = 1e6;      bool search(vector<int>& source, vector<int>& target, unordered_map<int, unordered_map<int, bool>>& blocked) {         unordered_map<int, unordered_map<int, bool>> visited;         visited[source[0]][source[1]] = true;          queue<pair<int, int>> bfs;         bfs.push({source[0], source[1]});          vector<int> rDiff = {0, 0, 1, -1};         vector<int> cDiff = {1, -1, 0, 0};         int area = 1;         while (!bfs.empty()) {             int r = bfs.front().first;             int c = bfs.front().second;             bfs.pop();              if (r == target[0] and c == target[1]) {                 return true;             }              if (area == 20000) { //这个地方不一定是20000， 就像围棋左上三角围成一个等边直角三角形，这个数量是19900-20000之间的一个数；                 return true;             }              for (int i = 0; i < 4; ++i) {                 int nr = r + rDiff[i];                 int nc = c + cDiff[i];                 if (nr >= 0 and nr < length and nc >= 0 and nc < length and !visited[nr][nc] and !blocked[nr][nc]) {                     area += 1;                     bfs.push({nr, nc});                     visited[nr][nc] = true;                 }             }         }         return false;     } public:     bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {         unordered_map<int, unordered_map<int, bool>> blocks;         for (vector<int>& b : blocked) {             blocks[b[0]][b[1]] = true;         }         return search(source, target, blocks) and search(target, source, blocks);     } }; ```  "},{title:"1042. 不邻接植花",path:"/posts/1042.%20%E4%B8%8D%E9%82%BB%E6%8E%A5%E6%A4%8D%E8%8A%B1.html",strippedContent:" #### [1042. 不邻接植花](https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/)  tag:graph  有 `N` 个花园，按从 `1` 到 `N` 标记。在每个花园中，你打算种下四种花之一。  `paths[i] = [x, y]` 描述了花园 `x` 到花园 `y` 的双向路径。  另外，没有花园有 3 条以上的路径可以进入或者离开。  你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。  以数组形式返回选择的方案作为答案 `answer`，其中 `answer[i]` 为在第 `(i+1)` 个花园中种植的花的种类。花的种类用  1, 2, 3, 4 表示。保证存在答案。     **示例 1：**  ``` 输入：N = 3, paths = [[1,2],[2,3],[3,1]] 输出：[1,2,3] ```  **示例 2：**  ``` 输入：N = 4, paths = [[1,2],[3,4]] 输出：[1,2,1,2] ```  **示例 3：**  ``` 输入：N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]] 输出：[1,2,3,4] ```    ```cpp class Solution { public:     vector<int> gardenNoAdj(int n, vector<vector<int>>& paths) {         vector<vector<int>> map(n + 1);         for(const auto& path:paths){             map[path[0]].push_back(path[1]);             map[path[1]].push_back(path[0]);         }          vector<int> ans(n,-1);         for(int i=1;i<=n;i++){             set<int> usedColor = {1,2,3,4};             for(const auto& neighbor:map[i]){                 if(ans[neighbor-1] !=-1)                     usedColor.erase(ans[neighbor-1]);             }             auto it = usedColor.begin();             ans[i-1] = *it;         }         return ans;              } };  ```  "},{title:"105. 从前序与中序遍历序列构造二叉树",path:"/posts/105.%20%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html",strippedContent:" #### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)  根据一棵树的前序遍历与中序遍历构造二叉树。  **注意:**  你可以假设树中没有重复的元素。  例如，给出  ``` 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] ```  返回如下的二叉树：  ```     3    / \\   9  20     /  \\    15   7 ```    ```cpp /**  * Definition for a binary tree node.  * struct TreeNode {  *     int val;  *     TreeNode *left;  *     TreeNode *right;  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}  * };  */ class Solution { public:     TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {         unordered_map<int,int> pos;         for(int i=0;i<inorder.size();i++){             pos[inorder[i]] = i;          }         function<TreeNode*(int,int,int,int)>buildTree = [&](int is,int ie,int ps,int pe){ //is: inorder start, ie: inorder end, ps: preorder start, pe: preorder end;             if (ps>pe) return (TreeNode*)nullptr; //这里注意是返回(TreeNode*)nullptr              int im = pos[preorder[ps]];             int pm = ps+(im-is);             auto root = new TreeNode(preorder[ps]);             root->left = buildTree(is,im-1,ps+1,pm);             root->right = buildTree(im+1,ie,pm+1,pe);             return root;         };         return buildTree(0,inorder.size()-1,0,preorder.size()-1);     } }; ```  这个题，就是从inorder里找到preorder[i] 的位置，然后对inorder数组，和preorder数组分别划分左右子树，不断递归求解。"},{title:"1092. 最短公共超序列",path:"/posts/1092.%20%E6%9C%80%E7%9F%AD%E5%85%AC%E5%85%B1%E8%B6%85%E5%BA%8F%E5%88%97.html",strippedContent:' #### [1092. 最短公共超序列](https://leetcode-cn.com/problems/shortest-common-supersequence/)  给出两个字符串 `str1` 和 `str2`，返回同时以 `str1` 和 `str2` 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。  （如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 **任意位置**），可以得到字符串 S，那么 S 就是 T 的子序列）     **示例：**  ``` 输入：str1 = "abac", str2 = "cab" 输出："cabac" 解释： str1 = "abac" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 的第一个 "c"得到 "abac"。  str2 = "cab" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 末尾的 "ac" 得到 "cab"。 最终我们给出的答案是满足上述属性的最短字符串。 ```     **提示：**  1. `1 <= str1.length, str2.length <= 1000` 2. `str1` 和 `str2` 都由小写英文字母组成。  ```cpp class Solution { public:     string shortestCommonSupersequence(string str1, string str2) {         int n1 = str1.length();         int n2 = str2.length();         str1 = \'#\'+str1;         str2 = \'#\'+str2;                  vector<vector<int>> dp(n1+1,vector<int>(n2+1,0));         for(int i=1;i<=n1;i++)             for(int j=1;j<=n2;j++){                 if(str1[i] == str2[j])                     dp[i][j] = dp[i-1][j-1]+1;                 else                      dp[i][j] = max(dp[i-1][j],dp[i][j-1]);             }          int i = n1, j = n2;         string ret;         while(i>0 && j>0){             if(str1[i]==str2[j]) //如果相同，那只用输出其中一个             {                 ret.push_back(str1[i]);                 i--;                 j--;             }             else if(dp[i][j] == dp[i-1][j]){//如果符合这个条件，那么肯定是str1超出的部分                 ret.push_back(str1[i]);                 i--;             }             else{ \t\t//由于str1超出的部分排出了，i现在是相同的str1的索引，所以这里就排出str2超出的部分                 ret.push_back(str2[j]);                 j--;             }         }         while(i>0){             ret.push_back(str1[i]);             i--;         }         while(j>0){             ret.push_back(str2[j]);             j--;         }         reverse(ret.begin(),ret.end());         return ret;      } }; ```  双序列dp，首先正着记录dp数组。 然后倒着输出。'},{title:"1122. 数组的相对排序",path:"/posts/1122.%20%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F.html",strippedContent:" #### [1122. 数组的相对排序](https://leetcode-cn.com/problems/relative-sort-array/)  给你两个数组，`arr1` 和 `arr2`，  - `arr2` 中的元素各不相同 - `arr2` 中的每个元素都出现在 `arr1` 中  对 `arr1` 中的元素进行排序，使 `arr1` 中项的相对顺序和 `arr2` 中的相对顺序相同。未在 `arr2` 中出现过的元素需要按照升序放在 `arr1` 的末尾。     **示例：**  ``` 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] 输出：[2,2,2,1,4,3,3,9,6,7,19] ```    ```cpp class Solution { public:     vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {         unordered_map<int,int> map_;                 for(auto m:arr2)             for(auto n:arr1)                 if(m == n){                     map_[m]++;                 }          vector<int> ans;         for(auto n:arr2){             int size = map_[n];             for(int i=0;i<size;++i)                 ans.push_back(n);         }          vector<int> ans1;         for(auto l:arr1)             if(!map_.count(l))                 ans1.push_back(l);                  sort(ans1.begin(),ans1.end());         ans.insert(ans.end(), ans1.begin(), ans1.end());         return ans;      } }; ```  这个题难点在于建立一个公共都有的元素的哈希表。这个哈希表不但可以起到区分arr1和arr2的作用，同时记录了这些元素在arr1中出现的次数。  另外记得 ans.insert(ans.end(), ans1.begin(), ans1.end());这种merge vercor的方法。    ```cpp class Solution { public: vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {     vector<int> res(1001); \tfor (int i = 0; i<arr1.size(); i++) \t{ \t\tres[arr1[i]]++; \t} \tint k = 0; \tfor (int i = 0; i<arr2.size(); i++) \t{ \t\twhile (res[arr2[i]]>0) \t\t{ \t\t\tarr1[k] = arr2[i];             k++; \t\t\tres[arr2[i]]--; \t\t} \t} \tfor (int i = 0; i < res.size(); i++) \t{ \t\twhile (res[i] >0) \t\t{ \t\t\tarr1[k] = i;             k++; \t\t\tres[i]--; \t\t} \t} \treturn arr1; } }; ```  这里贴一个别人的方法，用数组确实也起到map的作用。"},{title:"114. 二叉树展开为链表",path:"/posts/114.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8.html",strippedContent:" #### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)  给定一个二叉树，[原地](https://baike.baidu.com/item/原地算法/8010757)将它展开为一个单链表。     例如，给定二叉树  ```     1    / \\   2   5  / \\   \\ 3   4   6 ```  将其展开为：  ```cpp 1  \\   2    \\     3      \\       4        \\         5          \\           6 ```    ```cpp /**  * Definition for a binary tree node.  * struct TreeNode {  *     int val;  *     TreeNode *left;  *     TreeNode *right;  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}  * };  */ class Solution {  public:     void flatten(TreeNode* root) {         preorderBuild(root);     }      TreeNode* preorderBuild(TreeNode* root){         if(!root || !root->left && !root->right) return root;         preorderBuild(root->left);         preorderBuild(root->right);         TreeNode* p = root->left;         if(p){             while(p->right!=NULL)                   p=p->right;             p->right = root->right;             root->right = root->left;         }         root->left = NULL;         return root;              } }; ```  "},{title:"1245. 树的直径",path:"/posts/1245.%20%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84.html",strippedContent:" #### [c1245. 树的直径](https://leetcode-cn.com/problems/tree-diameter/)  给你这棵「无向树」，请你测算并返回它的「直径」：这棵树上最长简单路径的 **边数**。  我们用一个由所有「边」组成的数组 `edges` 来表示一棵无向树，其中 `edges[i] = [u, v]` 表示节点 `u` 和 `v` 之间的双向边。  树上的节点都已经用 `{0, 1, ..., edges.length}` 中的数做了标记，每个节点上的标记都是独一无二的。     **示例 1：**  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/31/1397_example_1.png)  ``` 输入：edges = [[0,1],[0,2]] 输出：2 解释： 这棵树上最长的路径是 1 - 0 - 2，边数为 2。 ```  **示例 2：**  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/31/1397_example_2.png)  ``` 输入：edges = [[0,1],[1,2],[2,3],[1,4],[4,5]] 输出：4 解释：  这棵树上最长的路径是 3 - 2 - 1 - 4 - 5，边数为 4。 ```     **提示：**  - `0 <= edges.length < 10^4` - `edges[i][0] != edges[i][1]` - `0 <= edges[i][j] <= edges.length` - `edges` 会形成一棵无向树  ```cpp class Solution { public:     int treeDiameter(vector<vector<int>>& edges) {         unordered_map<int,unordered_set<int>> map;         for(auto edge:edges){             int a=edge[0],b=edge[1];             map[a].insert(b);             map[b].insert(a);         }         queue<int> q;         int n = map.size();         for(int i=0;i<n;i++){             if(map[i].size()==1)                 q.push(i);         }          int flag = 0;         int step = 0;         while(!q.empty()){             int len = q.size();             if(len == 1)                 flag = 1;             if(len == 2)                 flag = 2;             while(len--){                 int cur = q.front();                 q.pop();                 for(auto next:map[cur]){                     map[next].erase(cur);                     if(map[next].size()==1)                         q.push(next);                 }             }             step++;         }                  int result = 0;         if(flag == 1)             result = (step-1)*2;         else if(flag == 2)             result = (step-1)*2+1;          return result;     } }; ```   这个题和310题用的同一个模板。    ```cpp 执行用时为 68 ms 的范例  class Solution { public:      static const int maxn = 10002;      int dist[maxn], vis[maxn];     vector<int> g[maxn];      void DFS(int i){         vis[i] = 1;         for(unsigned int k = 0; k < g[i].size(); k++){             int j = g[i][k];             if(!vis[j]){                 dist[j] = dist[i] + 1;                 DFS(j);             }         }     }      int treeDiameter(vector<vector<int>>& edges) {         int m = edges.size(), n = m + 1;          for(int i = 0; i < m; i++){             int u = edges[i][0], v = edges[i][1];             g[u].push_back(v);             g[v].push_back(u);         }          int root = 0;         DFS(root);          for(int i = 0; i < n; i++){             if(dist[i] > dist[root])root = i;         }          memset(vis, 0, sizeof(vis));          dist[root] = 0;         DFS(root);          for(int i = 0; i < n; i++){             if(dist[i] > dist[root])root = i;         }          return dist[root];     } }; ```  "},{title:"1167. 连接棒材的最低费用",path:"/posts/1167.%20%E8%BF%9E%E6%8E%A5%E6%A3%92%E6%9D%90%E7%9A%84%E6%9C%80%E4%BD%8E%E8%B4%B9%E7%94%A8.html",strippedContent:" #### [1167. 连接棒材的最低费用](https://leetcode-cn.com/problems/minimum-cost-to-connect-sticks/)  为了装修新房，你需要加工一些长度为正整数的棒材 `sticks`。  如果要将长度分别为 `X` 和 `Y` 的两根棒材连接在一起，你需要支付 `X + Y` 的费用。 由于施工需要，你必须将所有棒材连接成一根。  返回你把所有棒材 `sticks` 连成一根所需要的最低费用。注意你可以任意选择棒材连接的顺序。     **示例 1：**  ``` 输入：sticks = [2,4,3] 输出：14 解释：先将 2 和 3 连接成 5，花费 5；再将 5 和 4 连接成 9；总花费为 14。 ```  **示例 2：**  ``` 输入：sticks = [1,8,3,5] 输出：30 ```     **提示：**  - `1 <= sticks.length <= 10^4` - `1 <= sticks[i] <= 10^4`  ```cpp class Solution { public:     int connectSticks(vector<int>& sticks) {         priority_queue<int, vector<int>, greater<int> > q; // 小根堆         for (auto stick : sticks) {             q.push(stick);         }         int res = 0;         int cost = 0;         while(!q.empty()){                 cost = q.top();                 q.pop();                 if(q.empty()){                     break;                 }                 else{                     cost += q.top();                     q.pop();                     q.push(cost);                     res += cost;                  }         }         return res;      } }; ```    刚开始用数组，但是发现，这是个贪心，两个数加起来，就不是最小的了。  所以需要不断地去访问最小的，还是用priority_queue;"},{title:"1277. 统计全为 1 的正方形子矩阵",path:"/posts/1277.%20%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA%201%20%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5.html",strippedContent:" #### [1277. 统计全为 1 的正方形子矩阵](https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/)  给你一个 `m * n` 的矩阵，矩阵中的元素不是 `0` 就是 `1`，请你统计并返回其中完全由 `1` 组成的 **正方形** 子矩阵的个数。  dp   **示例 1：**  ``` 输入：matrix = [   [0,1,1,1],   [1,1,1,1],   [0,1,1,1] ] 输出：15 解释：  边长为 1 的正方形有 10 个。 边长为 2 的正方形有 4 个。 边长为 3 的正方形有 1 个。 正方形的总数 = 10 + 4 + 1 = 15. ```  **示例 2：**  ``` 输入：matrix =  [   [1,0,1],   [1,1,0],   [1,1,0] ] 输出：7 解释： 边长为 1 的正方形有 6 个。  边长为 2 的正方形有 1 个。 正方形的总数 = 6 + 1 = 7. ```     **提示：**  - `1 <= arr.length <= 300` - `1 <= arr[0].length <= 300` - `0 <= arr[i][j] <= 1`  ```cpp class Solution { public:     int countSquares(vector<vector<int>>& matrix) {         int m = matrix.size();         int n = matrix[0].size();         auto dp = vector<vector<int>>(m,vector<int>(n,0));         int count = 0;          for (int i=0; i<m; i++){             dp[i][0] = (matrix[i][0] == 1);             count += (matrix[i][0] == 1);         }          for (int j=1; j<n; j++){ //这里一定要注意， j是从1开始，小心算重复了             dp[0][j] = (matrix[0][j] == 1);             count += (matrix[0][j] == 1);         }          for (int i=1;i<m; i++){             for (int j=1;j<n; j++){                 if (matrix[i][j] == 0) continue;                 int k = min(dp[i-1][j],dp[i][j-1]);                 k = min(k,dp[i-1][j-1]);                 k += 1;                 dp[i][j] = k;                 count += k;              }         }         return count;       } };   ```  此题和`222.Maximal Square`几乎是同一道题，本质就是求01矩阵里面，以(i,j)为右下角的正方形最大边长是多少。边长多大，就意味着以(i,j)为右下角的正方形能有多少个。  解这类题目有一个非常有名的动态转移方程，就是`dp[i][j] = min(dp[i-1][j-1],dp[i][j-1],dp[i-1][j])+1`.也就是说，以(i,j)为右下角的正方形能有多大，取决于：以(i-1,j)为右下角的最大正方形，以(i,j-1)为右下角的最大正方形，以(i-1,j-1)为右下角的最大正方形，这三者最小的那一个。这是动态规划题目里最经典的“非典型应用”，希望能够记牢。  *注意第一行和第一列需要单独处理dp值。并且(0,0)元素不要重复计算。"},{title:"129. 求根到叶子节点数字之和",path:"/posts/129.%20%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C.html",strippedContent:" #### [129. 求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)  给定一个二叉树，它的每个结点都存放一个 `0-9` 的数字，每条从根到叶子节点的路径都代表一个数字。  例如，从根到叶子节点路径 `1->2->3` 代表数字 `123`。  计算从根到叶子节点生成的所有数字之和。  **说明:** 叶子节点是指没有子节点的节点。  **示例 1:**  ``` 输入: [1,2,3]     1    / \\   2   3 输出: 25 解释: 从根到叶子节点路径 1->2 代表数字 12. 从根到叶子节点路径 1->3 代表数字 13. 因此，数字总和 = 12 + 13 = 25. ```  **示例 2:**  ``` 输入: [4,9,0,5,1]     4    / \\   9   0  / \\ 5   1 输出: 1026 解释: 从根到叶子节点路径 4->9->5 代表数字 495. 从根到叶子节点路径 4->9->1 代表数字 491. 从根到叶子节点路径 4->0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026. ```  ```cpp /**  * Definition for a binary tree node.  * struct TreeNode {  *     int val;  *     TreeNode *left;  *     TreeNode *right;  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}  * };  */ class Solution { public:     int sumNumbers(TreeNode* root) {         if(!root) return 0;                  dfs(root,root->val);         return result;      }      //vector<int> ans;     //int res;     int result = 0;     void dfs(TreeNode* root,int currVal){         if (!root->left && !root->right)  {             result+=currVal; //这里是递归终止时需要传递的值             return;         }         if(root->left)//这一部分不能有关于currVal的任何计算             dfs(root->left,currVal*10+root->left->val); //只能在这里改变递归传递的值//         if(root->right)             dfs(root->right,currVal*10+root->right->val);              }; }; ```  这个题关键是想明白dfs。  "},{title:"1338. 数组大小减半",path:"/posts/1338.%20%E6%95%B0%E7%BB%84%E5%A4%A7%E5%B0%8F%E5%87%8F%E5%8D%8A.html",strippedContent:" #### [1338. 数组大小减半](https://leetcode-cn.com/problems/reduce-array-size-to-the-half/)  给你一个整数数组 `arr`。你可以从中选出一个整数集合，并删除这些整数在数组中的每次出现。  返回 **至少** 能删除数组中的一半整数的整数集合的最小大小。     **示例 1：**  ``` 输入：arr = [3,3,3,3,5,5,5,2,2,7] 输出：2 解释：选择 {3,7} 使得结果数组为 [5,5,5,2,2]、长度为 5（原数组长度的一半）。 大小为 2 的可行集合有 {3,5},{3,2},{5,2}。 选择 {2,7} 是不可行的，它的结果数组为 [3,3,3,3,5,5,5]，新数组长度大于原数组的二分之一。 ```  **示例 2：**  ``` 输入：arr = [7,7,7,7,7,7] 输出：1 解释：我们只能选择集合 {7}，结果数组为空。 ```  **示例 3：**  ``` 输入：arr = [1,9] 输出：1 ```  **示例 4：**  ``` 输入：arr = [1000,1000,3,7] 输出：1 ```  **示例 5：**  ``` 输入：arr = [1,2,3,4,5,6,7,8,9,10] 输出：5 ```     **提示：**  - `1 <= arr.length <= 10^5` - `arr.length` 为偶数 - `1 <= arr[i] <= 10^5`  ```cpp class Solution { public:     int minSetSize(vector<int>& arr) {         unordered_map<int,int> Map;         int ans = 1;         for(auto ele:arr){             Map[ele]++;         }         vector<int> t;         for(auto it=Map.begin();it!=Map.end();it++){             t.push_back(it->second);         }         sort(t.begin(),t.end(),greater<int>());          int sum = 0;         for(auto item:t){             sum += item;             if(sum<arr.size()/2)                 ans +=1;             else                 break;          }         return ans;      } }; ```  经常遇到这类问题，想要对unordered_map进行第二项排序，但是不好操作，因为 unordered_map本来就是个无序图，弄出来顺序，就不好办。 所以这里因为可以不管第一项，可以先把第二项都提取出来，再进行sort。     这里给出一种map 搭配pair的解法：  ```cpp class Solution { public:     static bool cmp(pair<int,int> a,pair<int,int> b){ //这里是static int也可         return a.second>b.second;     }     int minSetSize(vector<int>& arr) {         map<int,int> mp;         for(int i=0;i<arr.size();++i){             if(mp.find(arr[i])==mp.end()){                 mp[arr[i]]=1;             }else{                 mp[arr[i]]++;             }         }         vector<pair<int,int>> nums(mp.begin(),mp.end());         sort(begin(nums),end(nums),cmp);         int cur=0;         int count=0;         for(int i=0;i<nums.size();++i){             cur+=nums[i].second;             count++;             if(cur*2>=arr.size()) break;         }         return count;     } };   ```    更多可看这里：https://blog.csdn.net/iicy266/article/details/11906189"},{title:"1345. 跳跃游戏 IV",path:"/posts/1345.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20IV.html",strippedContent:" #### [1345. 跳跃游戏 IV](https://leetcode-cn.com/problems/jump-game-iv/)  给你一个整数数组 `arr` ，你一开始在数组的第一个元素处（下标为 0）。  每一步，你可以从下标 `i` 跳到下标：  - `i + 1` 满足：`i + 1 < arr.length` - `i - 1` 满足：`i - 1 >= 0` - `j` 满足：`arr[i] == arr[j]` 且 `i != j`  请你返回到达数组最后一个元素的下标处所需的 **最少操作次数** 。  注意：任何时候你都不能跳到数组外面。     **示例 1：**  ``` 输入：arr = [100,-23,-23,404,100,23,23,23,3,404] 输出：3 解释：那你需要跳跃 3 次，下标依次为 0 --\x3e 4 --\x3e 3 --\x3e 9 。下标 9 为数组的最后一个元素的下标。 ```  **示例 2：**  ``` 输入：arr = [7] 输出：0 解释：一开始就在最后一个元素处，所以你不需要跳跃。 ```  **示例 3：**  ``` 输入：arr = [7,6,9,6,9,6,9,7] 输出：1 解释：你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。 ```  **示例 4：**  ``` 输入：arr = [6,1,9] 输出：2 ```  **示例 5：**  ``` 输入：arr = [11,22,7,7,7,7,7,7,7,22,13] 输出：3 ```     **提示：**  - `1 <= arr.length <= 5 * 10^4` - `-10^8 <= arr[i] <= 10^8`  ```cpp class Solution { public:     int minJumps(vector<int>& arr) {         int n = arr.size();         if(n==1) return 0;         unordered_map<int,vector<int>> map;         for(int i=0;i<n;i++)             map[arr[i]].push_back(i);         vector<int> visited(n,0);         queue<int> q;         q.push(0);         visited[0]=1;          int step = 0;         while(!q.empty()){             int len = q.size();             while(len--){                 int cur = q.front();                 q.pop();                          if(cur+1<n && visited[cur+1]==0){                 q.push(cur+1);                 visited[cur+1] = 1;             }             if(cur-1>=0 && visited[cur-1]==0){                 q.push(cur-1);                 visited[cur-1]= 1;             }             for(int next:map[arr[cur]]){                 if(visited[next]==0){                     q.push(next);                     visited[next] =1;                 }             }             map.erase(arr[cur]);// 优化，避免元素重复被添加到队列         }         step +=1;         if(visited[n-1] == 1)             return step;         }         return -1;      } }; ```  BFS+ 优化。"},{title:"1356. 根据数字二进制下 1 的数目排序",path:"/posts/1356.%20%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B%201%20%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F.html",strippedContent:" #### [1356. 根据数字二进制下 1 的数目排序](https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/)  给你一个整数数组 `arr` 。请你将数组中的元素按照其二进制表示中数字 **1** 的数目升序排序。  如果存在多个数字二进制中 **1** 的数目相同，则必须将它们按照数值大小升序排列。  请你返回排序后的数组。     **示例 1：**  ``` 输入：arr = [0,1,2,3,4,5,6,7,8] 输出：[0,1,2,4,8,3,5,6,7] 解释：[0] 是唯一一个有 0 个 1 的数。 [1,2,4,8] 都有 1 个 1 。 [3,5,6] 有 2 个 1 。 [7] 有 3 个 1 。 按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7] ```  **示例 2：**  ``` 输入：arr = [1024,512,256,128,64,32,16,8,4,2,1] 输出：[1,2,4,8,16,32,64,128,256,512,1024] 解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。 ```  **示例 3：**  ``` 输入：arr = [10000,10000] 输出：[10000,10000] ```  **示例 4：**  ``` 输入：arr = [2,3,5,7,11,13,17,19] 输出：[2,3,5,17,7,11,13,19] ```  **示例 5：**  ``` 输入：arr = [10,100,1000,10000] 输出：[10,100,10000,1000] ```     **提示：**  - `1 <= arr.length <= 500` - `0 <= arr[i] <= 10^4`  ```cpp class Solution { public:     vector<int> sortByBits(vector<int>& arr) {         sort(arr.begin(), arr.end(), [&](int a, int b){             return make_pair(bitset<32>(a).count(), a) < make_pair(bitset<32>(b).count(), b);         });         return arr;     } };   ```  ## 偷懒的精髓  - 利用lambda表达式 - 利用bitset中count函数 - 利用pair的默认比较大小的方式"},{title:"1368. 使网格图至少有一条有效路径的最小代价",path:"/posts/1368.%20%E4%BD%BF%E7%BD%91%E6%A0%BC%E5%9B%BE%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E6%9D%A1%E6%9C%89%E6%95%88%E8%B7%AF%E5%BE%84%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BB%A3%E4%BB%B7.html",strippedContent:" #### [1368. 使网格图至少有一条有效路径的最小代价](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)  给你一个 m x n 的网格图 `grid` 。 `grid` 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 `grid[i][j]` 中的数字可能为以下几种情况：  - **1** ，下一步往右走，也就是你会从 `grid[i][j]` 走到 `grid[i][j + 1]` - **2** ，下一步往左走，也就是你会从 `grid[i][j]` 走到 `grid[i][j - 1]` - **3** ，下一步往下走，也就是你会从 `grid[i][j]` 走到 `grid[i + 1][j]` - **4** ，下一步往上走，也就是你会从 `grid[i][j]` 走到 `grid[i - 1][j]`  注意网格图中可能会有 **无效数字** ，因为它们可能指向 `grid` 以外的区域。  一开始，你会从最左上角的格子 `(0,0)` 出发。我们定义一条 **有效路径** 为从格子 `(0,0)` 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 `(m - 1, n - 1)` 结束的路径。有效路径 **不需要是最短路径** 。  你可以花费 `cost = 1` 的代价修改一个格子中的数字，但每个格子中的数字 **只能修改一次** 。  请你返回让网格图至少有一条有效路径的最小代价。     **示例 1：**  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png)  ``` 输入：grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]] 输出：3 解释：你将从点 (0, 0) 出发。 到达 (3, 3) 的路径为： (0, 0) --\x3e (0, 1) --\x3e (0, 2) --\x3e (0, 3) 花费代价 cost = 1 使方向向下 --\x3e (1, 3) --\x3e (1, 2) --\x3e (1, 1) --\x3e (1, 0) 花费代价 cost = 1 使方向向下 --\x3e (2, 0) --\x3e (2, 1) --\x3e (2, 2) --\x3e (2, 3) 花费代价 cost = 1 使方向向下 --\x3e (3, 3) 总花费为 cost = 3. ```  **示例 2：**  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid2.png)  ``` 输入：grid = [[1,1,3],[3,2,2],[1,1,4]] 输出：0 解释：不修改任何数字你就可以从 (0, 0) 到达 (2, 2) 。 ```  **示例 3：**  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid3.png)  ``` 输入：grid = [[1,2],[4,3]] 输出：1 ```  **示例 4：**  ``` 输入：grid = [[2,2,2],[2,2,2]] 输出：3 ```  **示例 5：**  ``` 输入：grid = [[4]] 输出：0 ```     **提示：**  - `m == grid.length` - `n == grid[i].length` - `1 <= m, n <= 100`  ```cpp class Solution { public:     int minCost(vector<vector<int>>& grid) {         const int m = grid.size();         const int n = grid[0].size();         vector<vector<int>> dp(m,vector<int>(n,INT_MAX/2));         dp[0][0]=0;         while(true){             auto prev(dp);             for(int i=0;i<m;i++)                     for(int j=0;j<n;j++){                     if(i>0) dp[i][j] = min(dp[i][j], dp[i-1][j]+(grid[i-1][j]!=3));                     if(j>0) dp[i][j] = min(dp[i][j],dp[i][j-1]+(grid[i][j-1]!=1));                    \t//从左上到右下，不断更新需要的最少改变数                 }              for(int i=m-1;i>=0;i--)                   for(int j=n-1;j>=0;j--){                     if(i!=m-1) dp[i][j] = min(dp[i][j],dp[i+1][j]+(grid[i+1][j]!=4));                     if(j!=n-1) dp[i][j] = min(dp[i][j],dp[i][j+1]+(grid[i][j+1]!=2));                     //从右下到左上，不断更新需要的最少改变数                 }              if(prev == dp) break;// 当dp二维数组不变了，就可以终止循环，退出。         }         return dp[m-1][n-1];     } };  ```  第一种方法是lazy bfs，实际上一直在更新dp。  从左上到右下 更新 再从右下到左上 更新，这样就能最后让这个dp表接上。  另外为什么不直接一个循环上下左右都访问一遍呢？ 因为那样拓展浪费时间 会超时。  ```cpp class Solution { public:     int minCost(vector<vector<int>>& grid) {         const int m = grid.size();         const int n = grid[0].size();         deque<pair<int,int>> q{{0,0}};// {pos,cost}          vector<char> seen(m*n);         vector<vector<int>> dirs{{1,0},{-1,0},{0,1},{0,-1}}; //向右，向左，向上，向下，这里怎么定义全看下面怎么引用，注意一定要匹配！！         while(!q.empty()){             auto [p,cost] = q.front(); q.pop_front();             int y = p%n, x=p/n;             if(x==m-1 && y==n-1) return cost;             if(seen[p]++) continue; //如果访问过，就跳过当前             for(int i=0;i<4;i++){                 int tx = x+dirs[i][1],ty = y+dirs[i][0];//调用4个方向，注意匹配，这里x是行坐标，y是列坐标。                 int tp = tx*n+ty;                 if(tx<0|| ty<0||tx>=m||ty>=n||seen[tp]) continue;                 if(grid[x][y] == i+1)                      q.emplace_front(tp,cost);                 else                     q.emplace_back(tp,cost+1);             }         }         return -1;              } }; ```  这个题可以说是十分巧妙。这里面用的是deque<pair<int,int>> 这种数据结构 ，主要是为了同时让队列元素具备位置和 当前cost两个变量，这样就能同时根据这两个参数进行判断。      ```cpp  ```  "},{title:"1383. 最大的团队表现值",path:"/posts/1383.%20%E6%9C%80%E5%A4%A7%E7%9A%84%E5%9B%A2%E9%98%9F%E8%A1%A8%E7%8E%B0%E5%80%BC.html",strippedContent:" #### [1383. 最大的团队表现值](https://leetcode-cn.com/problems/maximum-performance-of-a-team/)  公司有编号为 `1` 到 `n` 的 `n` 个工程师，给你两个数组 `speed` 和 `efficiency` ，其中 `speed[i]` 和 `efficiency[i]` 分别代表第 `i` 位工程师的速度和效率。请你返回由最多 `k` 个工程师组成的 **最大团队表现值** ，由于答案可能很大，请你返回结果对 `10^9 + 7` 取余后的结果。  **团队表现值** 的定义为：一个团队中「所有工程师速度的和」乘以他们「效率值中的最小值」。     **示例 1：**  ``` 输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2 输出：60 解释： 我们选择工程师 2（speed=10 且 efficiency=4）和工程师 5（speed=5 且 efficiency=7）。他们的团队表现值为 performance = (10 + 5) * min(4, 7) = 60 。 ```  **示例 2：**  ``` 输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3 输出：68 解释： 此示例与第一个示例相同，除了 k = 3 。我们可以选择工程师 1 ，工程师 2 和工程师 5 得到最大的团队表现值。表现值为 performance = (2 + 10 + 5) * min(5, 4, 7) = 68 。 ```  **示例 3：**  ``` 输入：n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4 输出：72 ```     **提示：**  - `1 <= n <= 10^5` - `speed.length == n` - `efficiency.length == n` - `1 <= speed[i] <= 10^5` - `1 <= efficiency[i] <= 10^8` - `1 <= k <= n`  ```cpp class Solution { public:     int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {         vector<pair<int,int>> es;         for(int i=0;i<n;i++)                 es.push_back({efficiency[i],speed[i]});         sort(rbegin(es),rend(es));         priority_queue<int,vector<int>, greater<int>> q;         long sum = 0;         long ans = 0;         for(int i=0;i<n;i++){             if(i>=k){                 sum -= q.top();                 q.pop();             }             sum += es[i].second;             q.push(es[i].second);             ans = max(ans,sum*es[i].first);          }          return ans % static_cast<int>(1e9 + 7);              } }; ```  这个题由于efficiency 影响较大， 所以对数据对进行pair后，按照efficency进行pair。  另外就是priority_queue的一个从小到大的写法，里面是greater<int>, 意思是从小到大，默认是从大到小。  sort默认是从小到大，用了rbegin和rend ， 就是从大到小了。    以下是内容补充：  priority_queue的总结：https://blog.csdn.net/xiaoquantouer/article/details/52015928  Sorting Vector of Pairs in C++：https://www.geeksforgeeks.org/sorting-vector-of-pairs-in-c-set-1-sort-by-first-and-second/"},{title:"1388. 3n 块披萨",path:"/posts/1388.%203n%20%E5%9D%97%E6%8A%AB%E8%90%A8.html",strippedContent:" #### [1388. 3n 块披萨](https://leetcode-cn.com/problems/pizza-with-3n-slices/)  给你一个披萨，它由 3n 块不同大小的部分组成，现在你和你的朋友们需要按照如下规则来分披萨：  - 你挑选 **任意** 一块披萨。 - Alice 将会挑选你所选择的披萨逆时针方向的下一块披萨。 - Bob 将会挑选你所选择的披萨顺时针方向的下一块披萨。 - 重复上述过程直到没有披萨剩下。  每一块披萨的大小按顺时针方向由循环数组 `slices` 表示。  请你返回你可以获得的披萨大小总和的最大值。     **示例 1：**  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_3_1723.png)  ``` 输入：slices = [1,2,3,4,5,6] 输出：10 解释：选择大小为 4 的披萨，Alice 和 Bob 分别挑选大小为 3 和 5 的披萨。然后你选择大小为 6 的披萨，Alice 和 Bob 分别挑选大小为 2 和 1 的披萨。你获得的披萨总大小为 4 + 6 = 10 。 ```  **示例 2：**  **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/sample_4_1723.png)**  ``` 输入：slices = [8,9,8,6,1,1] 输出：16 解释：两轮都选大小为 8 的披萨。如果你选择大小为 9 的披萨，你的朋友们就会选择大小为 8 的披萨，这种情况下你的总和不是最大的。 ```  **示例 3：**  ``` 输入：slices = [4,1,2,5,8,3,1,9,7] 输出：21 ```  **示例 4：**  ``` 输入：slices = [3,1,2] 输出：3 ```     **提示：**  - `1 <= slices.length <= 500` - `slices.length % 3 == 0` - `1 <= slices[i] <= 1000`  ```cpp class Solution { public:     int maxSizeSlices(vector<int>& slices) {         int n = slices.size();         return max(helper(0,n-2,n/3,slices),helper(1,n-1,n/3,slices));     }//这里0到n-2和 1到n-1分开算，这样就符合头尾不能共取的要求      int helper(int st,int en, int k, vector<int> slices){         vector<int>f(k+1,0);         vector<int>g(k+1,0);         for(int i=st;i<=en;i++)             for(int j=min(k,i-st+1);j>=1;j--){//限制j的次数，保证只取n/3次                 g[j] = max(g[j],f[j]); //本次不取，的当前最大值                  f[j] = g[j-1]+slices[i]; //本次取，则必须从前一次不取，即g[j-1]加上当前的slice值             }       return max(f[k],g[k]);         } }; ```  "},{title:"164.最大间距",path:"/posts/164.%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D.html",strippedContent:" #### [164. 最大间距](https://leetcode-cn.com/problems/maximum-gap/)  给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。  如果数组元素个数小于 2，则返回 0。  **示例 1:**  ``` 输入: [3,6,9,1] 输出: 3 解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。 ```  **示例 2:**  ``` 输入: [10] 输出: 0 解释: 数组元素个数小于 2，因此返回 0。 ```  **说明:**  - 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 - 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。    ```cpp class Solution { public:     int maximumGap(vector<int>& nums) {         const int n = nums.size();         if (n <= 1) return 0;                  const auto mm = minmax_element(nums.begin(), nums.end());         const int range = *mm.second - *mm.first;         const int bin_size = range / n +1; //这里+1 是一种对桶size的增加，如果不增加，桶太细了，有可能发生两个数之间本来是连接着的，结果中间出来一个INT_MIN         vector<int> min_vals(n, INT_MAX);         vector<int> max_vals(n, INT_MIN);         for (const int num : nums) {             const int index = (num - *mm.first) / bin_size;             min_vals[index] = min(min_vals[index], num);             max_vals[index] = max(max_vals[index], num);         }//分别更新大数桶和小数桶中的值，分别代表了这一段里的最大值，和最小值。         //并且，最小值和最大值之间可能是连续的，也可能是不连续的。 同时也可能最小值和最大值是同一值。                   int max_gap = 0;         int prev_max = max_vals[0];         for (int i = 1; i < n; ++i) {             if (min_vals[i] != INT_MAX) {                 max_gap = max(max_gap, min_vals[i] - prev_max);                 prev_max = max_vals[i];             }//这里一定用后面小的值减去前面大的值，因为后面小的和前面大的，是连续的两数，而后面大的和前面小很可能中间还有数，不连续。         }         return max_gap;     } }; ```  ``` 这一题用了桶排序，时间复杂度是O(n),很好的降低了复杂度，且没有用Sort()。 ```  "},{title:"19. 删除链表的倒数第N个节点",path:"/posts/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html",strippedContent:" /#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)  给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。  **示例：**  ``` 给定一个链表: 1->2->3->4->5, 和 n = 2.  当删除了倒数第二个节点后，链表变为 1->2->3->5. ```  **说明：**  给定的 *n* 保证是有效的。  **进阶：**  你能尝试使用一趟扫描实现吗？      ```cpp /**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     ListNode *next;  *     ListNode() : val(0), next(nullptr) {}  *     ListNode(int x) : val(x), next(nullptr) {}  *     ListNode(int x, ListNode *next) : val(x), next(next) {}  * };  */ class Solution { public:   ListNode* removeNthFromEnd(ListNode* head, int n) {     int l = 0;     ListNode* cur = head;     while (cur) { //统计总长度， 这个对于知道Linkedlist的长度至关重要       ++l;       cur = cur->next;     }     if (n == l) { //这里是如果是头结点是要删除的结点，特殊情况       ListNode* ans = head->next;       delete head;       return ans;     }          l -= n;     cur = head;     while (--l) cur = cur->next; //移动指针到合适位置     ListNode* node = cur->next;  //新的创建链表指针用于删除结点     cur->next = node->next;     delete node;     return head;   } }; ```    这个解法用了经典法，其实也可以用快慢指针。"},{title:"190. 颠倒二进制位",path:"/posts/190.%20%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D.html",strippedContent:" #### [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)  颠倒给定的 32 位无符号整数的二进制位。     **示例 1：**  ``` 输入: 00000010100101000001111010011100 输出: 00111001011110000010100101000000 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 ```  **示例 2：**  ``` 输入：11111111111111111111111111111101 输出：10111111111111111111111111111111 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，      因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 ```     **提示：**  - 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 - 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。因此，在上面的 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。     **进阶**:  如果多次调用这个函数，你将如何优化你的算法？    ```cpp class Solution { public:     uint32_t reverseBits(uint32_t n) {         vector<int> digits;         for(int i =0; i<32;i++){             int m = (n>>i)&1;             digits.push_back(m);         }                  uint32_t res = 0;                  //reverse(digits.begin(),digits.end());        for(int i=0;i<31;i++){            res = digits[i]+res<<1;        }         res += digits[31];         return res;                   } }; ```    ```cpp class Solution { public:     uint32_t reverseBits(uint32_t n) {         uint32_t res = 0;         for (int i = 0; i < 31; i++) {             res = (n % 2) + res << 1;             n >>= 1;         }         return res + n % 2;     } }; ```    bit manipulation  取最末尾的一位 可以 (n>>i)&1   也可以 n%2 。  如果不是返回整数，那么不断地res<< 1就可以了。"},{title:"1530. 好叶子节点对的数量",path:"/posts/1530.%20%E5%A5%BD%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F.html",strippedContent:" #### [1530. 好叶子节点对的数量](https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/)  tag：tree  给你二叉树的根节点 `root` 和一个整数 `distance` 。  如果二叉树中两个 **叶** 节点之间的 **最短路径长度** 小于或者等于 `distance` ，那它们就可以构成一组 **好叶子节点对** 。  返回树中 **好叶子节点对的数量** 。     **示例 1：**     ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e1.jpg)  ``` 输入：root = [1,2,3,null,4], distance = 3 输出：1 解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。 ```  **示例 2：**  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e2.jpg)  ``` 输入：root = [1,2,3,4,5,6,7], distance = 3 输出：2 解释：好叶子节点对为 [4,5] 和 [6,7] ，最短路径长度都是 2 。但是叶子节点对 [4,6] 不满足要求，因为它们之间的最短路径长度为 4 。 ```  **示例 3：**  ``` 输入：root = [7,1,4,6,null,5,3,null,null,null,null,null,2], distance = 3 输出：1 解释：唯一的好叶子节点对是 [2,5] 。 ```  **示例 4：**  ``` 输入：root = [100], distance = 1 输出：0 ```  **示例 5：**  ``` 输入：root = [1,1,1], distance = 2 输出：1 ```     **提示：**  - `tree` 的节点数在 `[1, 2^10]` 范围内。 - 每个节点的值都在 `[1, 100]` 之间。 - `1 <= distance <= 10`  ```cpp class Solution { public:   int countPairs(TreeNode* root, int distance) {     int ans = 0;     function<vector<int>(TreeNode*)> dfs        = [&](TreeNode* c) -> vector<int> {       // f[i] = number of leaves node at distance i.       vector<int> f(distance + 1);       if (!c) return f;             if (!c->left && !c->right) {                 f[0] = 1; // a single leaf node         return f;       }       const vector<int>& l = dfs(c->left);       const vector<int>& r = dfs(c->right);       for (int i = 0; i + 1 <= distance; ++i)         for (int j = 0; i + j + 2 <= distance; ++j)           ans += l[i] * r[j];       for (int i = 0; i < distance; ++i)         f[i + 1] = l[i] + r[i];       return f;     };     dfs(root);     return ans;   } }; ```    头目录必须包含：  \\#include <cstddef>  //这个用来识别NULL  \\#include <functional> // 这个用来识别lambda expression function "},{title:"1443. 收集树上所有苹果的最少时间",path:"/posts/1443.%20%E6%94%B6%E9%9B%86%E6%A0%91%E4%B8%8A%E6%89%80%E6%9C%89%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4.html",strippedContent:" #### [1443. 收集树上所有苹果的最少时间](https://leetcode-cn.com/problems/minimum-time-to-collect-all-apples-in-a-tree/)  给你一棵有 `n` 个节点的无向树，节点编号为 `0` 到 `n-1` ，它们中有一些节点有苹果。通过树上的一条边，需要花费 1 秒钟。你从 **节点 0** 出发，请你返回最少需要多少秒，可以收集到所有苹果，并回到节点 0 。  无向树的边由 `edges` 给出，其中 `edges[i] = [fromi, toi]` ，表示有一条边连接 `from` 和 `toi` 。除此以外，还有一个布尔数组 `hasApple` ，其中 `hasApple[i] = true` 代表节点 `i` 有一个苹果，否则，节点 `i` 没有苹果。     **示例 1：**  **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_1.png)**  ``` 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] 输出：8  解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。 ```  **示例 2：**  **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/10/min_time_collect_apple_2.png)**  ``` 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] 输出：6 解释：上图展示了给定的树，其中红色节点表示有苹果。一个能收集到所有苹果的最优方案由绿色箭头表示。 ```  **示例 3：**  ``` 输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] 输出：0 ```     **提示：**  - `1 <= n <= 10^5` - `edges.length == n-1` - `edges[i].length == 2` - `0 <= fromi, toi <= n-1` - `fromi < toi` - `hasApple.length == n`  ```cpp class Solution { public:     int minTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {         vector<vector<int>> g(n);         for(const auto& e:edges){              g[e[0]].push_back(e[1]);              g[e[1]].push_back(e[0]);         }         vector<int> seen(n);         function<int(int)> dfs = [&](int cur){             seen[cur] = 1;             int total = 0;             for(int child:g[cur]){                 if(seen[child]) continue;                 int cost = dfs(child);                 if(cost>0 || hasApple[child])                     total += 2 + cost;             }             return total;         } ;         return dfs(0);     } }; ```  这道题本质上，是一个图的dfs递归，看起来是树，其实 他没有用TreeNode 。  先把边的结点加到邻接表；  为了防止多次访问加seen数组进行标记和判断；  function<int(int)> dfs = [&] (int cur)  lambda表达式的写法要会。 function 然后是 <数据类型(数据类型)>  = [&]引用当前环境内变量 （传入的数据类型声明      变量名）{     }   。"},{title:"152. 乘积最大子数组",path:"/posts/152.%20%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84.html",strippedContent:" #### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)  给你一个整数数组 `nums` ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。     **示例 1:**  ``` 输入: [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 ```  **示例 2:**  ``` 输入: [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 ```    ```cpp class Solution { public:     int maxProduct(vector<int>& nums) {         int max_overall = nums[0];         int max_ending_here = nums[0], min_ending_here = nums[0];                  for(int i = 1; i < nums.size(); ++i){             int tmp = max_ending_here;             max_ending_here = max({nums[i], nums[i]*max_ending_here, nums[i]*min_ending_here});             min_ending_here = min({nums[i], nums[i]*tmp, nums[i]*min_ending_here});             max_overall = max(max_overall, max_ending_here);         }         return max_overall;     } }; ```  这里解释一下为什么要记录min_ending_here，因为这个是个最小的负值，如果下一个数也是负的，那么他就扭转乾坤变成最大的正值了。  max overall 存的是全局遍历过后的最大值，返回就OK。"},{title:"206. 反转链表",path:"/posts/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8.html",strippedContent:" #### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)  反转一个单链表。  **示例:**  ``` 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL ```  **进阶:**  你可以迭代或递归地反转链表。你能否用两种方法解决这道题？    ```cpp /**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     ListNode *next;  *     ListNode(int x) : val(x), next(NULL) {}  * };  */ class Solution { public:     ListNode* reverseList(ListNode* head) {         ListNode* curr = head;         ListNode* nxt ;         ListNode* prev = NULL;          while(curr){             nxt = curr->next;             curr->next = prev;             prev = curr;             curr = nxt;              }         return prev;      } }; ```    反转链表用了三个指针。 prev curr 和 nxt 。"},{title:"23.合并K个升序链表",path:"/posts/23.%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.html",strippedContent:" 23. 合并K个升序链表  给你一个链表数组，每个链表都已经按升序排列。  请你将所有链表合并到一个升序链表中，返回合并后的链表。     示例 1：  输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [   1->4->5,   1->3->4,   2->6 ] 将它们合并到一个有序链表中得到。 1->1->2->3->4->4->5->6  示例 2：  输入：lists = [] 输出：[]  示例 3：  输入：lists = [[]] 输出：[]     提示：      k == lists.length     0 <= k <= 10^4     0 <= lists[i].length <= 500     -10^4 <= lists[i][j] <= 10^4     lists[i] 按 升序 排列     lists[i].length 的总和不超过 10^4   ```cpp /**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     ListNode *next;  *     ListNode() : val(0), next(nullptr) {}  *     ListNode(int x) : val(x), next(nullptr) {}  *     ListNode(int x, ListNode *next) : val(x), next(next) {}  * };  */ class Solution { public:     ListNode* mergeKLists(vector<ListNode*>& lists) {         ListNode dummy(0);         ListNode* tail = &dummy;         auto camp =[](ListNode* a, ListNode* b) {return a->val> b->val;};         priority_queue<ListNode*,vector<ListNode*>,decltype(camp)>q(camp);          for(ListNode* list: lists)           if(list) q.push(list);          while(!q.empty()){             tail->next = q.top();             q.pop();             tail = tail->next;             if(tail->next) q.push(tail->next);          }          return dummy.next;              } }; ```    结合了priority_queue 与LinkedList。"},{title:"230. 二叉搜索树中第K小的元素",path:"/posts/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0.html",strippedContent:" #### [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)  tag:BST  给定一个二叉搜索树，编写一个函数 `kthSmallest` 来查找其中第 **k** 个最小的元素。  **说明：**  你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。  **示例 1:**  ``` 输入: root = [3,1,4,null,2], k = 1    3   / \\  1   4   \\    2 输出: 1 ```  **示例 2:**  ``` 输入: root = [5,3,6,2,4,null,null,1], k = 3        5       / \\      3   6     / \\    2   4   /  1 输出: 3 ```  **进阶：**  如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 `kthSmallest` 函数？    ```cpp class Solution { public:     int kthSmallest(TreeNode* root, int k) {         return inorder(root,k);     } private:     int inorder(TreeNode* root,int& k){//这里的&至关重要！！！         if(!root) return -1;         int x = inorder(root->left,k);         if(k == 0) return x;         if(--k == 0) return root->val;         return inorder(root->right,k);     } }; ```  &至关重要！！！&至关重要！！！&至关重要！！！  这里如果不对k 进行&索引，那么就会出现后面“if(--k == 0) return root->val; ”这句话执行之后，返回，结果k是当初递归调用时的那个k ， 也就是说--k没有改变k的值！！！  从这里我们能看出一个非常重要的东西: 索引&相当于内存上的存储的变量，在函数调用处理时，也想要改变它的值，想要全局维护它，那么索引&就一定要有。   否则，那些投进来的变量，容器也好，int也好，都不会被变，只再当前调用的函数环境下去变化,原来的写在内存上的内容不会被改变！  因为投进来的东西相当于新定义的东西！！    "},{title:"297. 二叉树的序列化与反序列化",path:"/posts/297.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html",strippedContent:' #### [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)  序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。  请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。  **示例:**   ``` 你可以将以下二叉树：      1    / \\   2   3      / \\     4   5  序列化为 "[1,2,3,null,null,4,5]" ```  **提示:** 这与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://leetcode-cn.com/faq/#binary-tree)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。  **说明:** 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。      ```cpp /**  * Definition for a binary tree node.  * struct TreeNode {  *     int val;  *     TreeNode *left;  *     TreeNode *right;  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}  * };  */ class Codec { public:      // Encodes a tree to a single string.     string serialize(TreeNode* root) {         ostringstream out;         serialize(root,out);         return out.str();     }      // Decodes your encoded data to tree.     TreeNode* deserialize(string data) {         istringstream in(data);         return deserialize(in);              } private:     enum STATUS{ //宏定义的状态量，可通过& 或 | 进行更新         ROOT_NULL = 0x0,         ROOT = 0x1,         LEFT = 0x2,         RIGHT = 0x4     };     void serialize(TreeNode* root,ostringstream& out){         char status = 0;         if (root) status|=ROOT;         if(root && root->left) status|=LEFT;         if(root && root->right) status|=RIGHT;         out.write(&status,sizeof(char));         if(!root) return;         out.write(reinterpret_cast<char*>(&(root->val)),sizeof(root->val));         if(root->left) serialize(root->left,out);         if(root->right) serialize(root->right,out);      }         TreeNode* deserialize(istringstream& in){         char status;         in.read(&status,sizeof (char));         if((!status) & ROOT) return nullptr;//这里判断读到的status ，如果是null， 取反后是111x1 ，与ROOT 与之后，如果 还有东西，即不是0000x0,那么就返回空节点指针；          auto root = new TreeNode(0);         in.read(reinterpret_cast<char*>(&root->val),sizeof(root->val));         root->left = (status & LEFT)? deserialize(in):nullptr;         root->right = (status & RIGHT)? deserialize(in):nullptr;         return root;      } };  // Your Codec object will be instantiated and called as such: // Codec ser, deser; // TreeNode* ans = deser.deserialize(ser.serialize(root)); ```  这个题用了很多东西  reinterpret_cast  ostringstream istringstream  都是为了尽量省去str to integer 这些转换的耗时 。  '},{title:"307. 区域和检索 - 数组可修改",path:"/posts/307.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2%20-%20%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9.html",strippedContent:" #### [307. 区域和检索 - 数组可修改](https://leetcode-cn.com/problems/range-sum-query-mutable/)  给定一个整数数组  *nums*，求出数组从索引 *i* 到 *j* (*i* ≤ *j*) 范围内元素的总和，包含 *i, j* 两点。  *update(i, val)* 函数可以通过将下标为 *i* 的数值更新为 *val*，从而对数列进行修改。  **示例:**  ``` Given nums = [1, 3, 5]  sumRange(0, 2) -> 9 update(1, 2) sumRange(0, 2) -> 8 ```  **说明:**  1. 数组仅可以在 *update* 函数下进行修改。 2. 你可以假设 *update* 函数与 *sumRange* 函数的调用次数是均匀分布的。  ```cpp class FenwickTree {     public:     FenwickTree(int n): sums_(n + 1, 0) {}          void update(int i, int delta) {         while (i < sums_.size()) {             sums_[i] += delta;             i += lowbit(i);         }     }          int query(int i) const {                 int sum = 0;         while (i > 0) {             sum += sums_[i];             i -= lowbit(i);         }         return sum;     } private:     static inline int lowbit(int x) { return x & (-x); }     vector<int> sums_; };   class NumArray { public:     NumArray(vector<int> nums): nums_(std::move(nums)), tree_(nums_.size()) {         for (int i = 0; i < nums_.size(); ++i)             tree_.update(i + 1, nums_[i]);     }          void update(int i, int val) {         tree_.update(i + 1, val - nums_[i]);         nums_[i] = val;     }          int sumRange(int i, int j) {         return tree_.query(j + 1) - tree_.query(i);     } private:     vector<int> nums_;     FenwickTree tree_; };  /**  * Your NumArray object will be instantiated and called as such:  * NumArray* obj = new NumArray(nums);  * obj->update(i,val);  * int param_2 = obj->sumRange(i,j);  */ ```  这里还有一个关于 fenwick tree初始化的优化：  ``` for i = 1 to n:     j = i + (i & -i)     # Finds next higher index that this value should contribute to     if j <= n:         x[j] += x[i] ```  "},{title:"312. 戳气球",path:"/posts/312.%20%E6%88%B3%E6%B0%94%E7%90%83.html",strippedContent:"#### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)  有 `n` 个气球，编号为`0` 到 `n-1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。  现在要求你戳破所有的气球。如果你戳破气球 `i` ，就可以获得 `nums[left] * nums[i] * nums[right]` 个硬币。 这里的 `left` 和 `right` 代表和 `i` 相邻的两个气球的序号。注意当你戳破了气球 `i` 后，气球 `left` 和气球 `right` 就变成了相邻的气球。  求所能获得硬币的最大数量。  **说明:**  - 你可以假设 `nums[-1] = nums[n] = 1`，但注意它们不是真实存在的所以并不能被戳破。 - 0 ≤ `n` ≤ 500, 0 ≤ `nums[i]` ≤ 100  **示例:**  ``` 输入: [3,1,5,8] 输出: 167  解释: nums = [3,1,5,8] --\x3e [3,5,8] --\x3e   [3,8]   --\x3e  [8]  --\x3e []      coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167 ```  ```cpp class Solution { public:     int maxCoins(vector<int>& nums) {         int n = nums.size();         nums.insert(nums.begin(),1);         nums.push_back(1);                  vector<vector<int>> c(n+2, vector<int>(n+2,0));         for(int l = 1; l <= n; ++l){ //戳破的气球总长度             for(int i = 1; i <= n - l +1; ++i){ //戳破气球起点                 int j = i + l -1; //戳破气球终点                 for(int k = i; k<=j; ++k){ //保留index是k的气球到最后戳破                     c[i][j] = max(c[i][j], c[i][k-1]+c[k+1][j]+nums[i-1]*nums[k]*nums[j+1]); //c[i][k-1]是k前面气球戳破分数，c[k+1][j]是k后面气球戳破分数                 }              }         }         return c[1][n]; //从头到尾戳破     } };  ```  "},{title:"32. 最长有效括号",path:"/posts/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html",strippedContent:' #### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)  给定一个只包含 `\'(\'` 和 `\')\'` 的字符串，找出最长的包含有效括号的子串的长度。  **示例 1:**  ``` 输入: "(()" 输出: 2 解释: 最长有效括号子串为 "()" ```  **示例 2:**  ``` 输入: ")()())" 输出: 4 解释: 最长有效括号子串为 "()()" ```  ```cpp class Solution { public:   int longestValidParentheses(string s) {     stack<int> q;     int start = 0;     int ans = 0;     for (int i = 0;i < s.length(); i++) {       if(s[i] == \'(\') {         q.push(i);       }        else {         if (q.empty()) {           start = i + 1;         }          else {           //int index = q.top();            q.pop();           ans = max(ans, q.empty() ? i - start + 1 : i - q.top());                 }       }     }     return ans;   } }; //"(())())))))))))))()(())())"  ```  这道题最关键的在于逻辑。  1.如果有左括号，压入堆栈；  2.如果是右括号： 1> 堆栈是空的， 这时候start 计数右移；  ​\t\t\t\t\t\t\t2>如果不为空，说明压入了左括号的index，就pop，  ​\t\t\t\t\t\t\t\t\t这时再更新ans，如果此时堆栈为空，就i-start+1，如果不为空就i-s.top();'},{title:"315. 计算右侧小于当前元素的个数",path:"/posts/315.%20%E8%AE%A1%E7%AE%97%E5%8F%B3%E4%BE%A7%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0.html",strippedContent:"#### [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)  tag：fenwick tree  给定一个整数数组 *nums*，按要求返回一个新数组 *counts*。数组 *counts* 有该性质： `counts[i]` 的值是 `nums[i]` 右侧小于 `nums[i]` 的元素的数量。     **示例：**  ``` 输入：nums = [5,2,6,1] 输出：[2,1,1,0]  解释： 5 的右侧有 2 个更小的元素 (2 和 1) 2 的右侧仅有 1 个更小的元素 (1) 6 的右侧有 1 个更小的元素 (1) 1 的右侧有 0 个更小的元素 ```     **提示：**  - `0 <= nums.length <= 10^5` - `-10^4 <= nums[i] <= 10^4`  ```cpp class FenwickTree { public:     FenwickTree(int n): sum_(n+1,0){}     void update(int i, int delta){         while(i<sum_.size()){             sum_[i]+=delta;             i += lowbit(i);         }     }         int query(int i) const{             int sum = 0;             while(i>0){                 sum+=sum_[i];                 i -=lowbit(i);             }             return sum;         } private:     static inline int lowbit(int x){return x & (-x);}     vector<int> sum_;   };  class Solution { public:     vector<int> countSmaller(vector<int>& nums) {         set<int> sorted(nums.begin(),nums.end());         unordered_map<int,int> ranks;         int rank = 0;         for(const int num:sorted){             ranks[num] = ++rank;         }         vector<int> ans;         FenwickTree tree(ranks.size());         for(int i=nums.size()-1;i>=0;i--){             ans.push_back(tree.query(ranks[nums[i]]-1));             tree.update(ranks[nums[i]],1);         }         reverse(ans.begin(),ans.end());         return ans;      } }; ```  这个题最厉害的在于，它用了fenwick tree。  Fenwick Tree 他的好处是有固定模板。  他也叫作 Binary indexed Tree。 这个tree 它 update自己一个数组的值，依靠一个固定的算法：  那就是他要每次把自己结点的值，加上向自己最后一个有效的二进制1位加一的那个index对应的值，一直加 加到i>tree node 的size；  query的方式不一样，在于它每次加的值是自己有效二级制位减一的那个index 对应的值，一直减，减到自己i<0为止；  通过对这个tree的一个 update和 query 从而得到想要的在自己前面比自己小的数的个数。  这个题是把原数组nums从后往前遍历，原因是我们要的是右边比index为i的数小的元素的数量，如果从前往后遍历，得到的将是左边比index为i的数小的元素的数量。  所以从后往前遍历完了以后，push_back进入ans的是最后一个元素的结果，所以需要最后的reverse。  ``` i: 0 nums: {5, 2, 6, 1} sorted: {[0] = 1, [1] = 2, [2] = 5, [3] = 6} ranks: {[6] = 4, [5] = 3, [2] = 2, [1] = 1} rank: 4 ans: {0, 1, 1, 2} tree: {sum_ = {0, 1, 2, 0, 3}} ```  "},{title:"327. 区间和的个数",path:"/posts/327.%20%E5%8C%BA%E9%97%B4%E5%92%8C%E7%9A%84%E4%B8%AA%E6%95%B0.html",strippedContent:" #### [327. 区间和的个数](https://leetcode-cn.com/problems/count-of-range-sum/)  给定一个整数数组 `nums`，返回区间和在 `[lower, upper]` 之间的个数，包含 `lower` 和 `upper`。  区间和 `S(i, j)` 表示在 `nums` 中，位置从 `i` 到 `j` 的元素之和，包含 `i` 和 `j` (`i` ≤ `j`)。  **说明:**  最直观的算法复杂度是 *O*(*n*2) ，请在此基础上优化你的算法。  **示例:**  ``` 输入: nums = [-2,5,-1], lower = -2, upper = 2, 输出: 3  解释: 3个区间分别是: [0,0], [2,2], [0,2]，它们表示的和分别为: -2, -1, 2。 ```  ```cpp class Solution { public:     int countRangeSum(vector<int>& nums, int lower, int upper) {         multiset<long long> helper;         helper.insert(0);         int ans=0;         long long sum=0;         for (int &i:nums)         {             sum+=i;             ans+=distance(helper.lower_bound(sum-upper),helper.upper_bound(sum-lower));             helper.insert(sum);         }         return ans;     } };   ```  "},{title:"376. 摆动序列",path:"/posts/376.%20%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html",strippedContent:"#### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)  如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。  例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。  给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。  **示例 1:**  ``` 输入: [1,7,4,9,2,5] 输出: 6  解释: 整个序列均为摆动序列。 ```  **示例 2:**  ``` 输入: [1,17,5,10,13,15,10,5,16,8] 输出: 7 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 ```  **示例 3:**  ``` 输入: [1,2,3,4,5,6,7,8,9] 输出: 2 ```      ```cpp class Solution { public:     int wiggleMaxLength(vector<int>& nums)      {         if (nums.size()==0) return 0;                  int p=1;         int q=1;                  for (int i=1; i<nums.size(); i++)         {             if (nums[i]>nums[i-1])                 p=q+1;             else if (nums[i]<nums[i-1])                 q=p+1;         }                  return max(p,q);              } }; ```  这个题是一个 dual status DP， p与q 唇齿相依，你中有我，我中有你。"},{title:"336. 回文对",path:"/posts/336.%20%E5%9B%9E%E6%96%87%E5%AF%B9.html",strippedContent:'#### [336. 回文对](https://leetcode-cn.com/problems/palindrome-pairs/)  给定一组 **互不相同** 的单词， 找出所有**不同** 的索引对`(i, j)`，使得列表中的两个单词， `words[i] + words[j]` ，可拼接成回文串。     **示例 1：**  ``` 输入：["abcd","dcba","lls","s","sssll"] 输出：[[0,1],[1,0],[3,2],[2,4]]  解释：可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"] ```  **示例 2：**  ``` 输入：["bat","tab","cat"] 输出：[[0,1],[1,0]]  解释：可拼接成的回文串为 ["battab","tabbat"] ```  ```cpp class Solution {     static bool cmp(string a,string b){             return a.size()<b.size();         } public:     vector<vector<int>> palindromePairs(vector<string>& words) {                   unordered_map<string,int> Map_;         unordered_set<string> Set;         int n = words.size();         for (int i=0;i<n;i++){             Map_[words[i]] = i;         }          sort(words.begin(),words.end(),cmp);          vector<vector<int>>results;          for(int i=0;i<n;i++){             string w = words[i];             for(int j=0;j<=w.size();j++){                 if(isPalindrome(w,0,j-1)){                     string w2 = w.substr(j);                     reverse(w2.begin(),w2.end());                     if(Set.find(w2)!=Set.end())                         results.push_back({Map_[w2],Map_[words[i]]});                 }                 if(isPalindrome(w,j,w.size()-1)){                     string w3 = w.substr(0,j);                     reverse(w3.begin(),w3.end());                     if (Set.find(w3)!=Set.end())                                             results.push_back({Map_[words[i]],Map_[w3]});                                         }                                  }             Set.insert(words[i]);         }         return results;               }     bool isPalindrome(string &w,int a,int b){         while(a<b){            if (w[a]!=w[b]) return false;            a++;            b--;         }         return true;     } };  ```    最直观的想法是将数组里的字符串两两比较，o(n^2)的时间复杂度，每次比较需要遍历两个字符串拼接后的全部长度，所以会超时。  AC的解法是构建一个集合，遍历字符串数组的过程中，将每个字符串与集合中已有的字符串进行考察，看是否有符合条件的配对。  首先，将字符串数组按照字符串长度从小到大排列：  ```cpp     static bool cmp(string a, string b)     {         return (a.size()<b.size());     }      sort(words.begin(),words.end(),cmp); ```  在遍历的过程中，假设string t=words[i];  遍历t的长度，将t拆分为两部分s1和s2. 注意这样的拆分，可以使s1从空字符串一直变化到t。  考虑两种情况是符合要求的：  1.s1的反序已经在集合中，并且s2本身就是回文，这样s1s2s1\'构成回文；  2.s2的反序已经在集合中，并且s1本身就是回文，这样s2\'s1s2构成回文。  然后就可以把t添加到集合中，考察下一个t。    ```cpp         for (int i=0; i<words.size(); i++)         {             string t=words[i];              for (int k=0; k<=t.size(); k++)             {                 string s1=t.substr(0,k);                 reverse(s1.begin(),s1.end());                 string s2=t.substr(k,t.size()-k);                 if (Set.find(s1)!=Set.end() && palindrome(s2))                     result.push_back({Map[t],Map[s1]});                                      s1=t.substr(0,k);                 s2=t.substr(k,t.size()-k);                 reverse(s2.begin(),s2.end());                                 if (Set.find(s2)!=Set.end() && palindrome(s1))                     result.push_back({Map[s2],Map[t]});                                  }                          Set.insert(t);         } ```'},{title:"381. O(1) 时间插入、删除和获取随机元素 - 允许重复",path:"/posts/381.%20O(1)%20%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0%20-%20%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D.html",strippedContent:"#### [381. O(1) 时间插入、删除和获取随机元素 - 允许重复](https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)  设计一个支持在*平均* 时间复杂度 **O(1)** 下**，** 执行以下操作的数据结构。  **注意: 允许出现重复元素。**  1. `insert(val)`：向集合中插入元素 val。 2. `remove(val)`：当 val 存在时，从集合中移除一个 val。 3. `getRandom`：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。  **示例:**  ``` // 初始化一个空的集合。 RandomizedCollection collection = new RandomizedCollection();  // 向集合中插入 1 。返回 true 表示集合不包含 1 。 collection.insert(1);  // 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。 collection.insert(1);  // 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。 collection.insert(2);  // getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。 collection.getRandom();  // 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。 collection.remove(1);  // getRandom 应有相同概率返回 1 和 2 。 collection.getRandom(); ```  ```cpp class RandomizedCollection { public:     /** Initialize your data structure here. */     RandomizedCollection() {      }          /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */     bool insert(int val) {         m_[val].push_back(vals_.size());         vals_.emplace_back(val,m_[val].size()-1);         return m_[val].size() == 1u;     }          /** Removes a value from the collection. Returns true if the collection contained the specified element. */     bool remove(int val) {         if(!m_.count(val)) return false;         int index_to_evict = m_[val].back();  //记录被移除的元素再哈希表中的位置。         const auto& last_entry = vals_.back(); //拿出数组中最后一个元素         m_[last_entry.first][last_entry.second] = index_to_evict; //改变数组中最后一个元素在哈希表中的index。         swap(vals_.back(),vals_[index_to_evict]); // 在数组中交换数组中最后一个元素，与要排出的元素的位置。          vals_.pop_back();         m_[val].pop_back();         if(m_[val].empty()) m_.erase(val);         return true;      }          /** Get a random element from the collection. */     int getRandom() {         return vals_[rand() %vals_.size()].first;      } private:     unordered_map<int,vector<int>> m_;     vector<pair<int,int>> vals_;  };  /**  * Your RandomizedCollection object will be instantiated and called as such:  * RandomizedCollection* obj = new RandomizedCollection();  * bool param_1 = obj->insert(val);  * bool param_2 = obj->remove(val);  * int param_3 = obj->getRandom();  */ ```  "},{title:"388. 文件的最长绝对路径",path:"/posts/388.%20%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84.html",strippedContent:'#### [388. 文件的最长绝对路径](https://leetcode-cn.com/problems/longest-absolute-file-path/)  假设我们以下述方式将我们的文件系统抽象成一个字符串:  字符串 `"dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext"` 表示:  ``` dir     subdir1     subdir2         file.ext ```  目录 `dir` 包含一个空的子目录 `subdir1` 和一个包含一个文件 `file.ext` 的子目录 `subdir2` 。  字符串 `"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext"` 表示:  ``` dir     subdir1         file1.ext         subsubdir1     subdir2         subsubdir2             file2.ext ```  目录 `dir` 包含两个子目录 `subdir1` 和 `subdir2`。 `subdir1` 包含一个文件 `file1.ext` 和一个空的二级子目录 `subsubdir1`。`subdir2` 包含一个二级子目录 `subsubdir2` ，其中包含一个文件 `file2.ext`。  我们致力于寻找我们文件系统中文件的最长 (按字符的数量统计) 绝对路径。例如，在上述的第二个例子中，最长路径为 `"dir/subdir2/subsubdir2/file2.ext"`，其长度为 `32` (不包含双引号)。  给定一个以上述格式表示文件系统的字符串，返回文件系统中文件的最长绝对路径的长度。 如果系统中没有文件，返回 `0`。  **说明:**  - 文件名至少存在一个 `.` 和一个扩展名。 - 目录或者子目录的名字不能包含 `.`。  要求时间复杂度为 `O(n)` ，其中 `n` 是输入字符串的大小。  请注意，如果存在路径 `aaaaaaaaaaaaaaaaaaaaa/sth.png` 的话，那么 `a/aa/aaa/file1.txt` 就不是一个最长的路径。    ```cpp class Solution { public:     int lengthLongestPath(string input)      {         vector<string>files;         for (int i=0; i<input.size(); i++)         {             int i0=i;             while (i<input.size() && input[i]!=\'\\n\')                 i++;             files.push_back(input.substr(i0,i-i0));         }                          vector<string>dir;         int result = 0;                  for (string str:files)         {             int k=0;             while (k<str.size() && str[k]==\'\\t\')                 k++;                                if (dir.size()<=k) dir.resize(k+1);                   dir[k] = str.substr(k);                                      if (dir[k].find(".")!=-1)             {                 int count = 0;                 for (int i=0; i<=k; i++)                     count+=dir[i].size();                 count+=k;                                  result = max(count,result);             }         }                  return result;              } }; ```    这个题主要是要会find()的用法， dir[k].find(".")!=-1 意思是找到了"."。'},{title:"399. 除法求值",path:"/posts/399.%20%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC.html",strippedContent:'#### [399. 除法求值](https://leetcode-cn.com/problems/evaluate-division/)  tag：并查集  给出方程式 `A / B = k`, 其中 `A` 和 `B` 均为用字符串表示的变量， `k` 是一个浮点型数字。根据已知方程式求解问题，并返回计算结果。如果结果不存在，则返回 `-1.0`。  输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。     **示例 1：**  ``` 输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]] 输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000] 解释： 给定：a / b = 2.0, b / c = 3.0 问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 返回：[6.0, 0.5, -1.0, 1.0, -1.0 ] ```  **示例 2：**  ``` 输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]] 输出：[3.75000,0.40000,5.00000,0.20000] ```  **示例 3：**  ``` 输入：equations = [["a","b"]], values = [0.5], queries = [["a","b"],["b","a"],["a","c"],["x","y"]] 输出：[0.50000,2.00000,-1.00000,-1.00000] ```     **提示：**  - `1 <= equations.length <= 20` - `equations[i].length == 2` - `1 <= equations[i][0].length, equations[i][1].length <= 5` - `values.length == equations.length` - `0.0 < values[i] <= 20.0` - `1 <= queries.length <= 20` - `queries[i].length == 2` - `1 <= queries[i][0].length, queries[i][1].length <= 5` - `equations[i][0], equations[i][1], queries[i][0], queries[i][1]` 由小写英文字母与数字组成  ```cpp class Solution { public:     vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {         unordered_map<string,pair<string,double>> parents;         for(int i=0;i<equations.size();i++){             const string& A = equations[i][0];             const string& B = equations[i][1];             const double k = values[i];             if(!parents.count(A)&&!parents.count(B)){                 parents[A]={B,k};                 parents[B]={B,1.0}; //这里千万注意： B的parents是他本身，权重是1.0；             }             else if(!parents.count(A)){                 parents[A]={B,k};             }             else if(!parents.count(B))                 parents[B] = {A,1.0/k};             else{                 auto &rA = find(A,parents);                 auto &rB = find(B,parents);                 parents[rA.first] = {rB.first,k/rA.second*rB.second};             }         }          vector<double> ans;         for (const auto& pair:queries){             const string& X=pair[0];             const string& Y=pair[1];             if(!parents.count(X)||!parents.count(Y)){                 ans.push_back(-1.0);                 continue;             }             auto& rX = find(X,parents);             auto& rY = find(Y,parents);             if(rX.first!=rY.first)                 ans.push_back(-1.0);             else                  ans.push_back(rX.second/rY.second);         }         return ans;      } private:     pair<string,double>& find(const string& C,unordered_map<string,pair<string,double>> &parents){         if(C!=parents[C].first){             const auto& p = find(parents[C].first,parents);             parents[C].first = p.first;             parents[C].second *= p.second;         }         return parents[C];     } };  ```  带权重并查集的经典题目，用的parents unordered_map<string,pair<string,double>> 作为集。  '},{title:"42. 接雨水",path:"/posts/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4.html",strippedContent:" #### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)  给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)  上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。  **示例:**  ``` 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 ```      ```cpp class Solution {//dp方法 public:   int trap(vector<int>& height) {     const int n = height.size();     vector<int> l(n);     vector<int> r(n);     int ans = 0;     for (int i = 0; i < n; ++i)       l[i] = i == 0 ? height[i] : max(l[i - 1], height[i]);     for (int i = n - 1; i >= 0; --i)       r[i] = i == n - 1 ? height[i] : max(r[i + 1], height[i]);     for (int i = 0; i < n; ++i)       ans += min(l[i], r[i]) - height[i];     return ans;   } }; ```    ```cpp class Solution {//stack方法  （和84题类似） public:     int trap(vector<int>& height)      {         stack<int>Stack;         int ret = 0;          for (int i=0; i<height.size(); i++)         {             while (!Stack.empty() && height[Stack.top()] < height[i])             {                                 int base = height[Stack.top()];                 Stack.pop();                 if (Stack.empty()) continue;                 int h = min(height[Stack.top()], height[i]) - base;                 int w = i - Stack.top()-1;                 ret += h*w;                             }             Stack.push(i);         }         return ret;     } }; ```  "},{title:"44. 通配符匹配",path:"/posts/44.%20%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D.html",strippedContent:" #### [44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)  tag：dp  给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。  ``` '?' 可以匹配任何单个字符。 '*' 可以匹配任意字符串（包括空字符串）。 ```  两个字符串**完全匹配**才算匹配成功。  **说明:**  - `s` 可能为空，且只包含从 `a-z` 的小写字母。 - `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `?` 和 `*`。  **示例 1:**  ``` 输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 ```  **示例 2:**  ``` 输入: s = \"aa\" p = \"*\" 输出: true 解释: '*' 可以匹配任意字符串。 ```  **示例 3:**  ``` 输入: s = \"cb\" p = \"?a\" 输出: false 解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。 ```  **示例 4:**  ``` 输入: s = \"adceb\" p = \"*a*b\" 输出: true 解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 \"dce\". ```  **示例 5:**  ``` 输入: s = \"acdcb\" p = \"a*c?b\" 输出: false ```  ```cpp class Solution { public:     bool isMatch(string s, string p) {         int M = s.size();         int N = p.size();         s = '#'+s;         p = '#'+p;         auto dp = vector<vector<int>>(M+1,vector<int>(N+1,0));          dp[0][0] = 1;         for(int i=1;i<=N;i++){             if(p[i] != '*') break; //必须是p开头就是*，否则s是空，p是有东西，就配对不上了；             dp[0][i] =1;         }         for(int i=1;i<=M;i++)             for(int j=1;j<=N;j++){                 if(p[j]=='?')                     dp[i][j] = dp[i-1][j-1];                 else if (p[j]=='*')                 {                     dp[i][j] = dp[i][j-1]|| dp[i-1][j]; //这里是一个递归的思想                 }                 else if(s[i] == p[j])                     dp[i][j] = dp[i-1][j-1];              }         return dp[M][N];     } }; ```  ``` 我们知道，当p[j]=='*'的前提下，我们有dp[i][j] = dp[0][j-1] || dp[1][j-1] || dp[2][j-1] || ... || dp[i-1][j-1] || dp[i][j-1] 在上式中，将i用i-1替换，就同理可以写出dp[i-1][j] = dp[0][j-1] || dp[1][j-1] || dp[2][j-1] || ... || dp[i-1][j-1]  用第二式替换第一式右边的大部分项，就有dp[i][j] = dp[i-1][j] || dp[i][j-1]. 惊喜不惊喜？ ```  "},{title:"5000.BFS模板",path:"/posts/5000.BFS%E6%A8%A1%E6%9D%BF.html",strippedContent:" ##  BFS模板  ```cpp vector<vector<int>> levelOrder(TreeNode* root) {     queue<TreeNode*> q;     q.push(root);     //...     while(q.size())     {         int size=q.size();         //...         for(int i=0;i<size;i++)         {             TreeNode* rt=q.front();q.pop();             //...             if(rt->left) q.push(rt->left);             if(rt->right) q.push(rt->right);         }     }     //return ... }   ```  "},{title:"50. Pow(x, n)",path:"/posts/50.%20Pow(x,%20n).html",strippedContent:" #### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)  实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。  **示例 1:**  ``` 输入: 2.00000, 10 输出: 1024.00000 ```  **示例 2:**  ``` 输入: 2.10000, 3 输出: 9.26100 ```  **示例 3:**  ``` 输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 ```  **说明:**  - -100.0 < *x* < 100.0 - *n* 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。  ```cpp class Solution {     double Pow_until(double x,long n){ //这里注意有一个test例子 是负的很大的数，这里必须用long         if(n==0) return 1;         if(n==1) return x;         if(n<0)  return Pow_until(1/x,-n);         double result = Pow_until(x*x,n/2);         if (n%2)  result *= x;         return result;        } public:     double myPow(double x, int n) {         return Pow_until(x,n);     } }; ```  "},{title:"351. 安卓系统手势解锁",path:"/posts/351.%20%E5%AE%89%E5%8D%93%E7%B3%BB%E7%BB%9F%E6%89%8B%E5%8A%BF%E8%A7%A3%E9%94%81.html",strippedContent:"#### [351. 安卓系统手势解锁](https://leetcode-cn.com/problems/android-unlock-patterns/)  我们都知道安卓有个手势解锁的界面，是一个 **3 x 3** 的点所绘制出来的网格。  给你两个整数，分别为 **m** 和 **n**，其中 1 ≤ m ≤ n ≤ 9，那么请你统计一下有多少种解锁手势，是至少需要经过 **m** 个点，但是最多经过不超过 **n** 个点的。     **先来了解下什么是一****个有效的安卓解锁手势:**  1. 每一个解锁手势必须至少经过 **m** 个点、最多经过 **n** 个点。 2. 解锁手势里不能设置经过重复的点。 3. 假如手势中有两个点是顺序经过的，那么这两个点的手势轨迹之间是绝对不能跨过任何未被经过的点。 4. 经过点的顺序不同则表示为不同的解锁手势。     ```  ```     **解释:**  ``` | 1 | 2 | 3 | | 4 | 5 | 6 | | 7 | 8 | 9 | ```  **无效手势：**`4 - 1 - 3 - 6 `  连接点 1 和点 3 时经过了未被连接过的 2 号点。  **无效手势：**`4 - 1 - 9 - 2`  连接点 1 和点 9 时经过了未被连接过的 5 号点。  **有效手势：**`2 - 4 - 1 - 3 - 6`  连接点 1 和点 3 是有效的，因为虽然它经过了点 2 ，但是点 2 在该手势中之前已经被连过了。  **有效手势：**`6 - 5 - 4 - 1 - 9 - 2`  连接点 1 和点 9 是有效的，因为虽然它经过了按键 5 ，但是点 5 在该手势中之前已经被连过了。     **示例:**  ``` 输入: m = 1，n = 1 输出: 9 ```    ```cpp class Solution { public:     bool isValid(int x,int y,vector<bool> & used){         if(used[y]){             return false;         }         /*sllash*/         if(!used[5]&& x + y == 10){             return false;         }         /*row*/         if(!used[min(x,y)+1]&&abs(x-y) == 2 && (x-1)/3 == (y-1)/3){             return false;         }         /*colum*/         if(!used[min(x,y)+3]&&abs(x-y) == 6 && (x-1)%3 == (y-1)%3){             return false;         }                  return true;     }          int dfs(int x,vector<bool>  & used,int count){         int res = 0;                  if(count < 0){             return 0;         }else if(count == 0){             return 1;         }                  for(int i = 1;i <= 9; ++i){             if(!used[i]&&isValid(x,i,used)){                 used[i] = true;                 res += dfs(i,used,count-1);                 used[i] = false;             }         }                  return res;     }          int countPatterns(int m){         int ans = 0;         vector<bool> used(10,false);         if(m <= 0){ return 0;}                  for(int i = 1;i <= 9; ++i){             used[i] = true;             ans += dfs(i,used,m-1);             used[i] = false;         }                  return ans;     }          int numberOfPatterns(int m, int n) {        int ans = 0;        for(int i = m;i <= n; ++i){            ans += countPatterns(i);        }        return ans;     } }; ```    ```cpp class Solution {     bool visited[3][3] = { false };     int patterns = 0;          bool valid_move(int ri, int ci, int next_ri, int next_ci) {         if (visited[next_ri][next_ci])             return false;                  int r_diff = next_ri - ri;         int c_diff = next_ci - ci;                  if (abs(r_diff) == 1 || abs(c_diff) == 1)             return true;         if (!visited[ri + r_diff / 2][ci + c_diff / 2])             return false;         return true;     }      void search(int m, int n, int ri, int ci) {         if (m <= 1)             patterns++;         if (n <= 1)             return;                  visited[ri][ci] = true;         for (int next_ri = 0; next_ri < 3; next_ri++)             for (int next_ci = 0; next_ci < 3; next_ci++)                 if (valid_move(ri, ci, next_ri, next_ci))                     search(m - 1, n - 1, next_ri, next_ci);         visited[ri][ci] = false;     } public:     int numberOfPatterns(int m, int n) {         search(m, n, 0, 0);         search(m, n, 0, 1);         patterns *= 4;          search(m, n, 1, 1);         return patterns;     } };  ```  "},{title:"5003.地板拼接（字节20201011第三题）",path:"/posts/5003.%E5%9C%B0%E6%9D%BF%E6%8B%BC%E6%8E%A5%EF%BC%88%E5%AD%97%E8%8A%8220201011%E7%AC%AC%E4%B8%89%E9%A2%98%EF%BC%89.html",strippedContent:' ## 地板拼接（字节20201011第三题）  博客来源：https://blog.csdn.net/u014634338/article/details/50015825  这个题目的题意很容易理解，在一个N*M的格子里，我们现在有两种类型的 砖块，1 * 2 和 2 * 1，问一共有多少种方案，可以将整个N*M的空间都填满。  最简单的例子就是下面的了：  ![img](https://img-my.csdn.net/uploads/201208/08/1344390743_5370.png)    编程之美中题目：  [某年夏天,位于希格玛大厦四层的微软亚洲研究院对办公楼的天井进行了一次大  规模的装修.原来的地板铺有 N×M 块正方形瓷砖,这些瓷砖都已经破损老化了,需要予以  更新.装修工人们在前往商店选购新的瓷砖时,发现商店目前只供应长方形的瓷砖,现在的 一块长方形瓷砖相当于原来的两块正方形瓷砖,  工人们拿不定主意该买多少了, 读者朋友们 请帮忙分析一下:能否用 1×2 的瓷砖去覆盖 N×M 的地板呢?](http://blog.csdn.net/hopeztm/article/details/7841917)     经典覆盖问题，输入n和m表示一个n*m的矩形，用1*2的方块进行覆盖，不能重叠，不能越出矩形边界，问完全覆盖完整个矩形有多少种不同的方案       下面分析过程属于部分转载：http://blog.csdn.net/hopeztm/article/details/7841917?utm_source=tuicool&utm_medium=referral  这个题目类属于状态压缩DP，对于状态压缩DP，其实最简单的理解就是把状态用比特位的形式表示出来，我们会在下面用例子来说明。  假如现在我们在铺砖 位置(i, j), 并且假设之前的位置已经铺设好的了，在这个位置，我们的选择：  \\1. 不用铺砖了，可能在(i-1, j)的时刻已经被竖着铺上了，然后考虑的是（i， j+1）    \\2. 横铺砖，将(i, j+1）也铺上了，然后考虑的是(i, j+2)  \\3. 竖着铺砖，（将i，j）和（i+1，j）铺上一个竖立的转头。      所以我们如下翻译我们的选择，在位置(i, j) 如果我们选择横着贴砖，那么将(i, j), (i, j+1)都填写成1， 如果竖着贴砖，我们将(i,j)填写成0， 将(i+1, j)填写成1.  为什么要这么计数呢，我觉得应该这样理解：  \\1. 在横着贴砖的时候，(i, j), (i, j+1) 都是1，这个值其实对下一行如何选择没有影响。  \\2. 竖着贴砖的第二个，我们也选择了1， 因为这个砖头结束了，对下一行如何选择依然没有影响。  \\3. 而竖着的第一个砖头，这个砖头是对下面有影响的，如果(i,j)是0，那么(i+1, j)只有是1的情况下才能满足条件。（这涉及到接下来的 状态兼容性问题）      对于竖着贴砖为什么这样选择，这样选择的一个好处是，我们在处理最后一行的时候，可以保证最后一行都是1， 因为最后一行绝对不能成为 竖砖开始，所以很容易取得最后的解。  好了，我们把这样理解的方案画成图：  ![img](https://img-my.csdn.net/uploads/201208/08/1344391503_6748.png)  如果我们将每一行都理解成一个二进制数字，那么  Row1 = 51,  Row2 = 15, Row3 = 48, Row4 = 63, Row5 = 51, Row6 = 63.  最后转头铺满的状态，一定是最后一行全是1。  我们用DP(i,j) 表示如下含义： 当第i行，达到状态j的时候，所能采取的方案数目。 所以明显我们的最后目的是求 DP(N, 2^M-1);      我们再来简单的分析一下为什么问题可以满足动态规划， 加入现在分析的对象是 DP(i,j)， 那么这一行有多少种铺设办法是和上一行相关的，  如果上一行的某个状态DP(i-1,k) 可以达到 DP(i, j) 我们认为这两个状态是兼容的，如果DP(i-1,k)和DP(i, j)兼容并且 DP(i-1,  k)有S中铺设方案，那么DP(i, j)就可以从DP(i-1, k)这条路径中获得S个方案。 当然这里k的取值可以是 0 ~~~~ 2^M  -1种取值。      现在我们来理解一下，什么叫做 j, k 兼容。  其实我们在上面已经基本给出分析， 如果我们现在铺设 (i,x) x这里表示第i行，第x列  \\1. 如果值 i  行，j 在x位上的值是0， 那么第 i-1行，j的值在x位上一定是1。因为不可能在同一列相邻的位置铺两个竖着的 第一个，如果满足下一步测试的是(i, x+1), 否则直接返回不兼容。  ![img](https://img-my.csdn.net/uploads/201208/08/1344394298_5250.png)    \\2. 如果值 i  行，j在x位置的值是1 .  {  ![img](https://img-my.csdn.net/uploads/201208/08/1344394399_5993.png)    ​      那么有可能有两种情况：  ​      \\1. (i-1, x)是0， 这个时候一定是竖着铺设了，下一步检测的是(i, x + 1)  ​      ![img](https://img-my.csdn.net/uploads/201208/08/1344394494_6716.png)  ​       \\2.  (i-1, x) 是1， 如果是这样的话，那么(i,  x)一定是要选择横着铺了，那么(i,x+1)也一定是1，并且(i-1, x +  1)一定是1（如果是0，就是竖着铺了），如果不满足就返回不兼容，满足条件 就测试(i, x + 2)  ​        ![img](https://img-my.csdn.net/uploads/201208/08/1344394649_3344.png)  }      对于第一行的兼容性，我们要做一下特别的分析，在第一行中，要么放0， 要么放1。  加入当前测试的是 DP(1, j)的第 x的比特位，即第1行，x列  \\1. 如果x是1，那么 x + 1 也一定是1，然后测试到 x + 2  \\2. 如果x是0， 那么直接测试下一个 x + 1  补充说明一点，当测试循环中，我们有时候必须要移动 1 位，有时候移动2位，当需要移动2位并且 x == M - 1(M列数）的时候，说明已经不可能兼容了。   下面贴出代码，并在代码中给予部分说明：     ```cpp #include <stdio.h> #include <string.h> #include <iostream> #include <algorithm> #include <vector> using namespace std; #define  mod 100000000 int n,m; long long dp[15][1<<12];   //设置初始状态 bool init(int status) {     for (int j=0; j<m;) //前j-1列符合要求，对第j列进行判断     {         if (status & (1<<j)) //第j列为1         {             if (j==m-1) //j为最后一列，不可行                 return false;             if (status & (1<<(j+1))) //第j列和第j+1列都为1 则表示横放，可行，考虑 j+2列                 j+=2;             else //第j列为1，第j+1列都为0不可行                 return false;         }         else //第j列为0 ，则为竖放，可行             j++;     }     return true; } //判断上一次状态和本次状态是否兼容 bool check(int now_s,int pre_s) {     for (int j=0; j<m; )     {         if (now_s & (1<<j)) //第i行第j列为1         {             if (pre_s & (1<<j)) //第i-1行第j列也为1，那么第i行必然是横放             {                 //第i行和第i-1行的第j+1都必须是1，否则是非法的                 if (j==m-1 || !(now_s & 1<<(j+1)) || !(pre_s & 1<<(j+1)))                     return false;                 else                     j+=2;             }             else                 j++; //第i-1行第j列为0，说明第i行第j列是竖放         }         else  //第i行第j列为0，那么第i-1行的第j列应该是已经填充了的         {             if (pre_s & (1<<j))                 j++;             else                 return false;         }     }     return true; }   void solve() {     int tot=(1<<m)-1;     memset(dp, 0, sizeof(dp));//复制字符 0（一个无符号字符）到参数 str (dp)所指向的字符串的前 n (sizeof(dp))个字符。     for (int s=0; s<=tot; s++)     {         if (init(s))             dp[1][s]=1;     }          for (int i=2; i<=n; i++) //按行dp     {         for (int j=0; j<=tot; j++) //第i行的状态         {             for (int k=0; k<=tot; k++) //第i-1行的状态             {                 if (check(j, k))                     dp[i][j]+=dp[i-1][k];             }         }     }     printf("%lld\\n",dp[n][tot]); } int main() {       while (scanf("%d%d",&n,&m) && (n||m))     {         if (n&1 && m&1) //n和m均为奇数的话，矩形面积就是奇数，可知是不可能完全覆盖的         {             printf("0\\n");             continue;         }         if (n<m) //交换n和m使n较大m较小，这样能减少状态数             swap(n, m);         solve();     }     return 0; } ```  '},{title:"5001.求强连通分量",path:"/posts/5001.%E6%B1%82%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F.html",strippedContent:" ### 求强连通分量  Kosaraju算法：https://zh.wikipedia.org/wiki/Kosaraju%E7%AE%97%E6%B3%95  https://edwiv.com/archives/564    Tarjan算法：https://zh.wikipedia.org/wiki/Tarjan%E7%AE%97%E6%B3%95    ### 并查集详解  图文解说：https://blog.csdn.net/liujian20150808/article/details/50848646        "},{title:"5004.输出所有的最长公共子串",path:"/posts/5004.%E8%BE%93%E5%87%BA%E6%89%80%E6%9C%89%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2.html",strippedContent:' ## 输出所有的最长公共子串  上述讲到使用动态规划可以在 θ(mn) 的时间里求出 LCS 的长度，下面将讨论如何输出最长公共子串。  问题描述：给定两个序列，例如 X = “ABCBDAB”、Y = “BDCABA”，求它们的最长公共子串的长度。  下面是求解时的动态规划表，可以看出 X 和 Y 的最长公共子串的长度为2：  ![img](https://pic3.zhimg.com/80/v2-541861d0d359988663b6d6100ffa719a_1440w.jpg)  输出最长公共子串很简单，只需要判断table[i][j]是否等于最长公共子串的长度即可，然后沿着对角线往左上角找大于等于1的数字即可；  1. 如果table[i][j] == lcs_len（lcs_len指最长公共子串长度），则把这个字符放入LCS中，并跳入table[i-1][j-1]中继续进行判断； 2. 直到table[i][j] < 1为止；倒序输出LCS放入set中。  从上图的红色路径显示，X 和 Y 的最长公共子串有 3 个，分别为 “BD”、“AB”、“AB”。  因“AB”与“AB”重复，故只输出“BD”、“AB”即可。  C++代码如下：  ```cpp // 动态规划求解并输出所有LCS #include <iostream> #include <string> #include <vector> #include <set> #include <algorithm> using namespace std;  string x = "ABCBDAB"; string y = "BDCABA"; vector<vector<int>> table; // 动态规划表 set<string> setOflcs;      // set保存所有的LCS  /**  * 构造表，并返回X和Y的LCS的长度  */ int lcs(int m, int n) {     int biggest = 0;     // 表的大小为(m+1)*(n+1)     table = vector<vector<int>>(m+1, vector<int>(n+1));     for(int i = 0; i < m+1; i++)     {         for(int j = 0; j < n+1; j++)         {             // 第一行和第一列置0             if(i == 0 || j == 0)                 table[i][j] = 0;             else if(x[i-1] == y[j-1])             { \t\ttable[i][j] = table[i-1][j-1] + 1; \t\tif(table[i][j] > biggest)                     biggest = table[i][j]; // 存放LCS的长度 \t    } \t    else \t\ttable[i][j] = 0;         }     }     return biggest; }  /**  * 求出所有的最长公共子串，并放入set中  */ void traceBack(int m, int n, int lcs_len) {     string strOflcs;     for(int i = 1; i < m+1; i++)     {         for(int j = 1; j < n+1; j++)         {             // 查到等于lcs_len的值，取字符             if(table[i][j] == lcs_len)             {                 int ii = i, jj = j;                 while(table[ii][jj] >= 1)                 {                     strOflcs.push_back(x[ii-1]);                     ii--;                     jj--;                 }                 string str(strOflcs.rbegin(), strOflcs.rend()); // strOflcs逆序                 if((int)str.size() == lcs_len)                       // 判断str的长度是否等于lcs_len                 {                     setOflcs.insert(str);                     strOflcs.clear();                           // 清空strOflcs                 }             }         }     } }  // 输出set void print() {     set<string>::iterator iter = setOflcs.begin();     for(; iter != setOflcs.end(); iter++)         cout << *iter << endl; }  int main() {     int m = x.length();     int n = y.length();     int res = lcs(m, n);     cout << "res = " << res << endl;      traceBack(m, n, res);     print();      getchar();     return 0; }  ```  '},{title:"556. 下一个更大元素 III",path:"/posts/556.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%20III.html",strippedContent:"#### [556. 下一个更大元素 III](https://leetcode-cn.com/problems/next-greater-element-iii/)  tag：string  给定一个**32位**正整数 **n**，你需要找到最小的**32位**整数，其与 **n** 中存在的位数完全相同，并且其值大于n。如果不存在这样的**32位**整数，则返回-1。  **示例 1:**  ``` 输入: 12 输出: 21 ```  **示例 2:**  ``` 输入: 21 输出: -1 ```  ```cpp class Solution { public:     int nextGreaterElement(int n) {         vector<int> digits;         while(n>0){             digits.push_back(n%10);             n=n/10;         }        int i=1;         while(i<digits.size()&&digits[i]>=digits[i-1]){            i++;        }         if (i==digits.size()) return -1;          int j=0;        while(j<digits.size()&&digits[j]<=digits[i]){            j++;        }         swap(digits[i],digits[j]);        sort(digits.begin(),digits.begin()+i);        reverse(digits.begin(),digits.begin()+i);          long result = 0;        for(int i=digits.size()-1;i>=0;i--){           result *=10;           result += digits[i];        }         if (result > INT_MAX) return -1;         return result;       } };    ```  这里主要是一个考虑  xxx34321  xxx43321    如果全降序，那么肯定是没有了；  找到第一个非降序，index是i；  找到第一个大于刚才index是i的数，index为j；  交换i和j的数，然后再进行排序，再翻转顺序；  最后转化输出。"},{title:"600. 不含连续1的非负整数",path:"/posts/600.%20%E4%B8%8D%E5%90%AB%E8%BF%9E%E7%BB%AD1%E7%9A%84%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0.html",strippedContent:"#### [600. 不含连续1的非负整数](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/)(难题)  tag：dp  给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 **连续的1** 的个数。  **示例 1:**  ``` 输入: 5 输出: 5 解释:  下面是带有相应二进制表示的非负整数<= 5： 0 : 0 1 : 1 2 : 10 3 : 11 4 : 100 5 : 101 其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。 ```  **说明:** 1 <= n <= 109   答案引用自wisdompeak：    ```cpp class Solution { public:     int findIntegers(int num)      {                 if (num==0) return 0;         if (num==1) return 2;                  vector<int>f(33);         f[0]=1;         f[1]=2;         for (int i=2; i<32; i++)                     f[i]=f[i-2]+f[i-1];                          vector<int>digits(32,0);         for (int i=0; i<32; i++)                 digits[i]=((num>>i)&1);                     int count=0;         for (int i=31; i>=0; i--)         {             if (digits[i]==0) continue;                          // 第i位取0             count+=f[i-1+1];                            // 第i位取1             if (i-1>=0 && digits[i-1]==1)             {                 count+=f[i-2+1];                 return count;             }         }                  count++;                  return count;              } }; ```    先考虑一个简单的问题：对于一个n位的01字符串，没有连续1的排列有多少？这是一个简单的DP问题。考虑dp[i]时，如果第i位是0，则1～i-1位可以自由排列为任何无连续1的组合，即dp[i-1]。如果第i位是1，则第i-1位只能是0，那么从1～i-2位可以自由排列为任何无连续1的组合，即dp[i-2].所以动态转移方程是：  dp[i]=dp[i-1]+dp[i-2]  注意初始条件，dp[0]=1, dp[1]=2; dp[0]是起辅助作用。  那么对于本题而言，我们先将num转化为二进制的字符串。  考虑第i位是1的情况： ***1xxxxxxxxxx，那么如果保留所有的*且第i位取0，那么第i+1～n位可以自由排列为任何无连续1的组合，都是小于***1xxxxxxxxxx的，即有dp[n-i]个; 如果第i位取1，那么就要继续查看后面的数组才能保证不大于num。  比如，假设往后看到 ***101xxxxxxxx， 即第i+2位是1（隔了一个0），那么可以重复之前的分析：保留所有*，将第i+2位取0，则有dp[n-i-2]种排列，它们满足小于***101xxxxxxxx，且无连续1的条件；如果将第i+2位取1，则需要继续往后查看。  但是，如果看到第i+1位出现了这种情况：***11xxxxxxxxx，即第i+1位和第i位一样都是1。注意到，第i+1位是不能取1的（否则连续两个1），所以第i+1位只能取0，这样则有dp[n-i-1]种组合符合要求。但特别注意，num在第i+1位之后的数字我们其实就不用查看了，因为第i+1位已经锁定为0了，这样的01组合一定小于等于num。此时就要退出循环。  注意一个细节：如果num从头到尾都没有任何连续的1出现，那么最后就要把result++，因为虽然一路都是把当前位的取值等同于digits[i]，但最后并没有包含num本身。"},{title:"617. 合并二叉树",path:"/posts/617.%20%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html",strippedContent:"#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)  给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。  你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为** NULL 的节点将直接作为新二叉树的节点。  **示例 1:**  ``` 输入:  \tTree 1                     Tree 2                             1                         2                                       / \\                       / \\                                     3   2                     1   3                                /                           \\   \\                             5                             4   7                   输出:  合并后的树: \t     3 \t    / \\ \t   4   5 \t  / \\   \\  \t 5   4   7 ```  **注意:** 合并必须从两个树的根节点开始。    ```cpp /**  * Definition for a binary tree node.  * struct TreeNode {  *     int val;  *     TreeNode *left;  *     TreeNode *right;  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}  * };  */ class Solution { public:     TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {         auto m = mergeTreesProcess(t1,t2);         return m;     } private:     TreeNode* mergeTreesProcess(TreeNode* t1, TreeNode* t2){         if(!t1) return t2 ;         if(!t2) return t1 ;         TreeNode* p = new TreeNode(t1->val+t2->val);         //p->val = t1->val+t2->val;         p->left = mergeTreesProcess(t1->left,t2->left);         p->right = mergeTreesProcess(t1->right,t2->right);         return p;     }  }; ```  这里需要注意，TreeNode* p = new TreeNode(t1->val+t2->val);   也可以TreeNode(0), 然后再定义 p->val =  **** ;  当然不能忘了 p->left 和 p->right 都分别指向哪个节点。"},{title:"621.任务调度器",path:"/posts/621.%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8.html",strippedContent:' 21. 任务调度器  给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。  然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。  你需要计算完成所有任务所需要的最短时间。     示例 ：  输入：tasks = ["A","A","A","B","B","B"], n = 2 输出：8 解释：A -> B -> (待命) -> A -> B -> (待命) -> A -> B.      在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。      提示：      任务的总个数为 [1, 10000]。     n 的取值范围为 [0, 100]。     ```cpp class Solution { public:     int leastInterval(vector<char>& tasks, int n) {         vector<int> count(26, 0);                 for (const char task : tasks)              ++count[task - \'A\'];  //统计各个字母任务出现的个数；         const int max_count = *max_element(count.begin(), count.end()); //找出出现频率最高的字母；         size_t ans = (max_count - 1) * (n + 1);           ans += count_if(count.begin(), count.end(),                         [max_count](int c){ return c == max_count; });         return max(tasks.size(), ans);     } }; ```    tasks = ["A","A","A","B","B","B"], n = 2 为例子，  “A” “B”  空 “A” “B”  空 “A” “B”  空  这样执行完 ，所以是(max_count - 1) * (n+1) = (3-1)*(2+1) = 6  6+p = 6+2 =8    这里p是和最高频率任务一样频率的字母的个数和；  AB和空 为一组，有max_count - 1组，其中每组n+1个任务，这就是前max_count-1组的任务之和，再加上p个任务，分别是最高频率任务一样频率的字母的个数和以及该最高任务。  这里，需要学会函数，*max_element（ .begin(),.end()）,以及count_if(.begin(),.end(),[]  )      '},{title:"636. 函数的独占时间",path:"/posts/636.%20%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4.html",strippedContent:' #### 636. 函数的独占时间](https://leetcode-cn.com/problems/exclusive-time-of-functions/)  tag：stack  给出一个非抢占单线程CPU的 **n** 个函数运行日志，找到函数的独占时间。  每个函数都有一个唯一的 Id，从 **0** 到 **n-1**，函数可能会递归调用或者被其他函数调用。  日志是具有以下格式的字符串：`function_id：start_or_end：timestamp`。例如：`"0:start:0"` 表示函数 0 从 0 时刻开始运行。`"0:end:0"` 表示函数 0 在 0 时刻结束。  函数的独占时间定义是在该方法中花费的时间，调用其他函数花费的时间不算该函数的独占时间。你需要根据函数的 Id 有序地返回每个函数的独占时间。  **示例 1:**  ``` 输入: n = 2 logs =  ["0:start:0",  "1:start:2",  "1:end:5",  "0:end:6"] 输出:[3, 4] 说明： 函数 0 在时刻 0 开始，在执行了  2个时间单位结束于时刻 1。 现在函数 0 调用函数 1，函数 1 在时刻 2 开始，执行 4 个时间单位后结束于时刻 5。 函数 0 再次在时刻 6 开始执行，并在时刻 6 结束运行，从而执行了 1 个时间单位。 所以函数 0 总共的执行了 2 +1 =3 个时间单位，函数 1 总共执行了 4 个时间单位。 ```  **说明：**  1. 输入的日志会根据时间戳排序，而不是根据日志Id排序。 2. 你的输出会根据函数Id排序，也就意味着你的输出数组中序号为 0 的元素相当于函数 0 的执行时间。 3. 两个函数不会在同时开始或结束。 4. 函数允许被递归调用，直到运行结束。 5. 1 <= n <= 100    ```cpp class Solution { public:     vector<int> exclusiveTime(int n, vector<string>& logs) {         stack<pair<int,int>> Stack;         vector<int> results(n);          for (auto s:logs){             int pos1 = s.find(":",0);             int pos2 = s.find(":",pos1+1);             int id = stoi(s.substr(0,pos1)); //这里是从开头到pos1那么长  ，id有可能是多位数             bool flag = s.substr(pos1+1,pos2-pos1-1)=="start"?true:false;             int timeStamp = stoi(s.substr(pos2+1)); //这里是从开头到pos2到末尾，id有可能是多位数              if(flag)                 Stack.push({id,timeStamp});             else{                 int start = Stack.top().second;                 int duration = timeStamp - start +1;                 results[id] += duration;                 Stack.pop();                  if(!Stack.empty()){                     int previd = Stack.top().first;                     results[previd] -= duration;                 }             }           }         return results;      } }; ```    这个题关键是要会 s.substr() 的用法，以及stoi() 用法；  ```cpp     // string::substr     #include <iostream>     #include <string>     int main ()     {     std::string str="We think in generalities, but we live in details.";     // (quoting Alfred N. Whitehead)     std::string str2 = str.substr (3,5); // "think"     std::size_t pos = str.find("live"); // position of "live" in str     std::string str3 = str.substr (pos); // get from "live" to the end 这里是到结尾       std::cout << str2 << \' \' << str3 << \'\\n\';     return 0;     } ```  '},{title:"684. 冗余连接",path:"/posts/684.%20%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5.html",strippedContent:" #### [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)  tag：并查集  在本问题中, 树指的是一个连通且无环的**无向**图。  输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。  结果图是一个以`边`组成的二维数组。每一个`边`的元素是一对`[u, v]` ，满足 `u < v`，表示连接顶点`u` 和`v`的**无向**图的边。  返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 `[u, v]` 应满足相同的格式 `u < v`。  **示例 1：**  ``` 输入: [[1,2], [1,3], [2,3]] 输出: [2,3] 解释: 给定的无向图为:   1  / \\ 2 - 3 ```  **示例 2：**  ``` 输入: [[1,2], [2,3], [3,4], [1,4], [1,5]] 输出: [1,4] 解释: 给定的无向图为: 5 - 1 - 2     |   |     4 - 3 ```  **注意:**  - 输入的二维数组大小在 3 到 1000。 - 二维数组中的整数在1到N之间，其中N是输入数组的大小。  ```cpp class UnionFindSet { public:              UnionFindSet(int n){             ranks_ = vector<int>(n+1,0);//这里初始化值为1到n都可以，rank只在Union的时候+1更新；             parents = vector<int>(n+1,0);             for(int i=0;i<parents.size();i++){                 parents[i] = i;             }         }          bool Union(int u,int v){             int pu = Find(u);             int pv = Find(v);             if (pu == pv) return false;             if(ranks_[pu]>ranks_[pv])                 parents[pv] = pu;             else if(ranks_[pu]<ranks_[pv])                 parents[pu] = pv;             else{                 parents[pv] = pu;                  ranks_[pu] +=1; //这里pv,pu都可以跑，但实际上应该给父亲结点+1；             }             return true;         }          int Find(int u){             if(u!=parents[u])                 parents[u] = Find(parents[u]);             return parents[u];         } private:     vector<int> ranks_;     vector<int> parents;      }; class Solution{ public:    vector<int> findRedundantConnection(vector<vector<int>>& edges){        UnionFindSet s(edges.size());        for(const auto& edge:edges)         if(!s.Union(edge[0],edge[1]))              return edge;          return {};     }  }; ```  并查集经典题目。  先UnionFindSet， 然后把边依次送入并查集，把最后一个加入导致边连成环的边返回。"},{title:"72. 编辑距离",path:"/posts/72.%20%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html",strippedContent:"#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)  给你两个单词 *word1* 和 *word2*，请你计算出将 *word1* 转换成 *word2* 所使用的最少操作数 。  你可以对一个单词进行如下三种操作：  1. 插入一个字符 2. 删除一个字符 3. 替换一个字符     **示例 1：**  ``` 输入：word1 = \"horse\", word2 = \"ros\" 输出：3 解释： horse -> rorse (将 'h' 替换为 'r') rorse -> rose (删除 'r') rose -> ros (删除 'e') ```  **示例 2：**  ``` 输入：word1 = \"intention\", word2 = \"execution\" 输出：5 解释： intention -> inention (删除 't') inention -> enention (将 'i' 替换为 'e') enention -> exention (将 'n' 替换为 'x') exention -> exection (将 'n' 替换为 'c') exection -> execution (插入 'u') ```  ```cpp class Solution { public:     int minDistance(string word1, string word2) {         int l1 = word1.length();         int l2 = word2.length();          vector<vector<int>> dp(l1+1,vector<int>(l2+1,0));         for(int i=0;i<=l1;i++)             dp[i][0] = i;         for(int j=0;j<=l2;j++)             dp[0][j] = j;                  for(int i=1;i<=l1;i++)             for(int j=1;j<=l2;j++){                 int c = (word1[i-1] == word2[j-1] )? 0:1; //判断末尾是不是相同的，如果相同，那么操作数不增加；如果不相同，操作数c 加1.                 dp[i][j] = min(dp[i-1][j-1]+c,                             min(dp[i-1][j],dp[i][j-1])+1);                 //三种情况，第一种有可能需要加c， 剩下两种一定需要一次操作，                 //即删除前一个，或者删除后一个             }         return dp[l1][l2];     } }; ```  "},{title:"722. 删除注释",path:"/posts/722.%20%E5%88%A0%E9%99%A4%E6%B3%A8%E9%87%8A.html",strippedContent:' #### [722. 删除注释](https://leetcode-cn.com/problems/remove-comments/)  tag：string  给一个 C++ 程序，删除程序中的注释。这个程序`source`是一个数组，其中`source[i]`表示第`i`行源码。 这表示每行源码由`\\n`分隔。  在 C++ 中有两种注释风格，行内注释和块注释。  字符串`//` 表示行注释，表示`//`和其右侧的其余字符应该被忽略。  字符串`/*` 表示一个块注释，它表示直到`*/`的下一个（非重叠）出现的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串`/*/`并没有结束块注释，因为注释的结尾与开头相重叠。  第一个有效注释优先于其他注释：如果字符串`//`出现在块注释中会被忽略。 同样，如果字符串`/*`出现在行或块注释中也会被忽略。  如果一行在删除注释之后变为空字符串，那么**不要**输出该行。即，答案列表中的每个字符串都是非空的。  样例中**没有**控制字符，单引号或双引号字符。比如，`source = "string s = "/* Not a comment. */";"` 不会出现在测试样例里。（此外，没有其他内容（如定义或宏）会干扰注释。）  我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的`/*`总是开始新的注释。  最后，隐式换行符**可以**通过块注释删除。 有关详细信息，请参阅下面的示例。  从源代码中删除注释后，需要以相同的格式返回源代码。  **示例 1:**  ``` 输入:  source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]  示例代码可以编排成这样: /*Test program */ int main() {    // variable declaration  int a, b, c; /* This is a test    multiline      comment for     testing */ a = b + c; }  输出: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]  编排后: int main() {     int a, b, c; a = b + c; }  解释:  第 1 行和第 6-9 行的字符串 /* 表示块注释。第 4 行的字符串 // 表示行注释。 ```  **示例 2:**  ``` 输入:  source = ["a/*comment", "line", "more_comment*/b"] 输出: ["ab"] 解释: 原始的 source 字符串是 "a/*comment\\nline\\nmore_comment*/b", 其中我们用粗体显示了换行符。删除注释后，隐含的换行符被删除，留下字符串 "ab" 用换行符分隔成数组时就是 ["ab"]. ```  **注意:**  - `source`的长度范围为`[1, 100]`. - `source[i]`的长度范围为`[0, 80]`. - 每个块注释都会被闭合。 - 给定的源码中不会有单引号、双引号或其他控制字符。  ```cpp class Solution { public:     vector<string> removeComments(vector<string>& source) {         vector<string> ans;         bool inblock=false;         string currline= "";         for (auto line:source){             int n=line.size();             if(!inblock){                 currline="";             }             for(int i=0;i<n;i++){                 if(i<n-1&&line[i]==\'/\'&&line[i+1]==\'*\'&&!inblock){                     inblock = true;                      i++;                 }                              else if(i<n-1&&line[i]==\'*\'&&line[i+1]==\'/\'&&inblock){                     inblock = false;                     i++;                 }                 else if(i<n-1&&line[i]==\'/\'&&line[i+1]==\'/\'&&!inblock)                     break;                 else if(!inblock){                     currline += line[i];                 }             }             if(currline.size()>0 && !inblock)                 ans.push_back(currline);         }             return ans;     } }; ```    注意这个题的写法，if +（else if）*3'},{title:"767. Reorganize String_贪心",path:"/posts/767.%20Reorganize%20String_%E8%B4%AA%E5%BF%83.html",strippedContent:' \\767. Reorganize String  Medium  Given a string `S`, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.  If possible, output any possible result. If not possible, return the empty string.  **Example 1:**  ``` Input: S = "aab" Output: "aba" ```  **Example 2:**  ``` Input: S = "aaab" Output: "" ```  **Note:**  - `S` will consist of lowercase letters and have length in range `[1, 500]`.  ```cpp class Solution { public:     string reorganizeString(string S) {                  unordered_map<char,int> map;                  for(auto ch:S) map[ch]++;   //采用char int 无序图；         priority_queue<pair<int,char>> pq;            for(auto a:map) pq.push({a.second,a.first});  //将无序图加入priority_queue，从而得到排序                   string result;                  while(!pq.empty()){             int k = min(2,(int)pq.size());//每次只排两个              vector<pair<int,char>> temp;  //进行记录                          for (int i=0;i<k; i++){                 int ch = pq.top().second;                 int num = pq.top().first;                 pq.pop();                 result += ch;                 num--;                 if (num!=0) temp.push_back({num,ch});  //此时该字母还有，则准备把他塞入pq             }             if (k<2 && temp.size()>0) return ""; //此时就是最后一个，这个时候如果他还是temp里有货，那么重复是无法避免的；             for (auto a:temp) pq.push(a);         }         return result;       } };  ```    这个题目的思路，就是一种贪心策略，首先把原题转化为每2个进行组合排列，取出现频率最高的两个，然后见他们取出来，分别num--,再把他们塞到temp缓存变量里，在经过判断后，将temp塞回到pq里去，从而模拟了整个过程。 最后如果出现 k<2 && temp.size()>0这种情况，那么可以说重复是不可避免的。'},{title:"787. K 站中转内最便宜的航班",path:"/posts/787.%20K%20%E7%AB%99%E4%B8%AD%E8%BD%AC%E5%86%85%E6%9C%80%E4%BE%BF%E5%AE%9C%E7%9A%84%E8%88%AA%E7%8F%AD.html",strippedContent:" #### [787. K 站中转内最便宜的航班](https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/)  有 `n` 个城市通过 `m` 个航班连接。每个航班都从城市 `u` 开始，以价格 `w` 抵达 `v`。  现在给定所有的城市和航班，以及出发城市 `src` 和目的地 `dst`，你的任务是找到从 `src` 到 `dst` 最多经过 `k` 站中转的最便宜的价格。 如果没有这样的路线，则输出 `-1`。     **示例 1：**  ``` 输入:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 1 输出: 200 解释:  城市航班图如下   从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。 ```  **示例 2：**  ``` 输入:  n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]] src = 0, dst = 2, k = 0 输出: 500 解释:  城市航班图如下   从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。 ```     **提示：**  - `n` 范围是 `[1, 100]`，城市标签从 `0` 到 `n`` - 1` - 航班数量范围是 `[0, n * (n - 1) / 2]` - 每个航班的格式 `(src, ``dst``, price)` - 每个航班的价格范围是 `[1, 10000]` - `k` 范围是 `[0, n - 1]` - 航班没有重复，且不存在自环  ```cpp class Solution { public:     int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int K) {         constexpr int kInfCost = 1e9;         vector<vector<int>> dp(K+2,vector<int>(n,kInfCost));         dp[0][src] = 0;         for(int i=1;i<=K+1;i++){             dp[i][src] = 0;             for(const auto& p:flights){                 dp[i][p[1]] = min(dp[i][p[1]],dp[i-1][p[0]]+p[2]);             }          }         return dp[K+1][dst] >= kInfCost?-1:dp[K+1][dst];      } };  //dp: {{0, 1000000000, 1000000000}, {0, 100, 500}, {0, 100, 200}} //构造dp，使得dp[K+1][dst]为解，即K+1是换乘次数，dst是目的地，不断更新到达目的地的最短距离，从而得解 Bellman-ford ```  ```latex 贝尔曼-福特算法与迪科斯彻算法类似，都以松弛操作为基础，即估计的最短路径值渐渐地被更加准确的值替代，直至得到最优解。在两个算法中，计算时每个边之间的估计距离值都比真实值大，并且被新找到路径的最小长度替代。 然而，迪科斯彻算法以贪心法选取未被处理的具有最小权值的节点，然后对其的出边进行松弛操作；而贝尔曼-福特算法简单地对所有边进行松弛操作，共 | V | − 1 {\\displaystyle |V|-1} {\\displaystyle |V|-1}次，其中 | V | {\\displaystyle |V|} {\\displaystyle |V|}是图的点的数量。在重复地计算中，已计算得到正确的距离的边的数量不断增加，直到所有边都计算得到了正确的路径。这样的策略使得贝尔曼-福特算法比迪科斯彻算法适用于更多种类的输入。  贝尔曼-福特算法的最多运行 O ( | V | ⋅ | E | ) {\\displaystyle O(|V|\\cdot |E|)} {\\displaystyle O(|V|\\cdot |E|)}（大O符号）次， | V | {\\displaystyle |V|} |V|和 | E | {\\displaystyle |E|} |E|分别是节点和边的数量）。  ```  ```cpp int SPFA(int s) { \tqueue<int> q; \tbool inq[maxn] = {false}; \tfor(int i = 1; i <= N; i++) dis[i] = 2147483647; \tdis[s] = 0; \tq.push(s); inq[s] = true; \twhile(!q.empty()) { \t\tint x = q.front(); q.pop(); \t\tinq[x] = false; \t\tfor(int i = front[x]; i !=0 ; i = e[i].next) { \t\t\tint k = e[i].v; \t\t\tif(dis[k] > dis[x] + e[i].w) { \t\t\t\tdis[k] = dis[x] + e[i].w; \t\t\t\tif(!inq[k]) { \t\t\t\t\tinq[k] = true; \t\t\t\t\tq.push(k); \t\t\t\t} \t\t\t} \t\t} \t} \tfor(int i =  1; i <= N; i++) cout << dis[i] << ' '; \tcout << endl; \treturn 0; } ```  "},{title:"572. 另一个树的子树",path:"/posts/572.%20%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91.html",strippedContent:"#### [572. 另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)  给定两个非空二叉树 **s** 和 **t**，检验 **s** 中是否包含和 **t** 具有相同结构和节点值的子树。**s** 的一个子树包括 **s** 的一个节点和这个节点的所有子孙。**s** 也可以看做它自身的一棵子树。  **示例 1:**  给定的树 s:  ```      3     / \\    4   5   / \\  1   2 ```  给定的树 t：  ```    4    / \\  1   2 ```  返回 **true**，因为 t 与 s 的一个子树拥有相同的结构和节点值。  **示例 2:**  给定的树 s：  ```      3     / \\    4   5   / \\  1   2     /    0 ```  给定的树 t：  ```    4   / \\  1   2 ```  返回 **false**。    ```cpp class Solution {  public: void subtreeComparator(TreeNode* s, TreeNode* t,bool &areIdentical){          if(!s&&!t||!areIdentical) return;     if(!s||!t||s->val!=t->val)            {areIdentical = false; return; }     if(s->val == t->val && areIdentical){         subtreeComparator(s->left,t->left,areIdentical);         subtreeComparator(s->right,t->right,areIdentical);     }      }     bool isSubtree(TreeNode* s,TreeNode* t){         if(s->val == t->val){             bool areIdentical(true);             subtreeComparator(s,t,areIdentical);             if (areIdentical) return true;                      }         return (s->left && isSubtree(s->left,t) || s->right && isSubtree(s->right,t));              }  }; ```  这个题，最关键的是subtreeComparator() 这个函数里逻辑的构造，以及他的递归调用。"},{title:"8000.ubuntu系统安装cuda后，鼠标键盘失效解决办法",path:"/posts/8000.ubuntu%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85cuda%E5%90%8E%EF%BC%8C%E9%BC%A0%E6%A0%87%E9%94%AE%E7%9B%98%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html",strippedContent:" ubuntu系统安装cuda后，鼠标键盘失效解决办法    首先明确，本人的情况是Windows + ubuntu18.04。再安装了cuda10.0后，重启电脑再进入桌面，鼠标和键盘就失效拉，不能用，这个时候需要强制关机。  再次开机，由于是双系统，会自动进入grub引导界面，就是选择系统进入界面。  \\1. 选中ubuntu, 按 e 进入编辑界面  \\2. 在编辑界面的倒数第二行，就算现实linux 内核的那一行的最后打个空格然后写个3，如下：  linux.................................... 3  \\3. 然后按F10或 ctrl +x  \\4. 进入了文本模型，输入账户，秘密  \\5. 输入以下命令  sudo apt-get install xserver-xorg-input-all  这一切都需要联网情况下  \\6. reboot重启即可   "},{title:"818. 赛车",path:"/posts/818.%20%E8%B5%9B%E8%BD%A6.html",strippedContent:' #### [818. 赛车](https://leetcode-cn.com/problems/race-car/)  你的赛车起始停留在位置 0，速度为 +1，正行驶在一个无限长的数轴上。（车也可以向负数方向行驶。）  你的车会根据一系列由 A（加速）和 R（倒车）组成的指令进行自动驾驶 。  当车得到指令 "A" 时, 将会做出以下操作： `position += speed, speed *= 2`。  当车得到指令 "R" 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为 `speed = -1` ；否则将车速调整为 `speed = 1`。 (当前所处位置不变。)  例如，当得到一系列指令 "AAR" 后, 你的车将会走过位置 0->1->3->3，并且速度变化为 1->2->4->-1。  现在给定一个目标位置，请给出能够到达目标位置的最短指令列表的**长度**。  ``` 示例 1: 输入:  target = 3 输出: 2 解释:  最短指令列表为 "AA" 位置变化为 0->1->3 示例 2: 输入:  target = 6 输出: 5 解释:  最短指令列表为 "AAARA" 位置变化为 0->1->3->7->7->6 ```  **说明:**   - `1 <= target（目标位置） <= 10000`。  ![img](http://zxi.mytechroad.com/blog/wp-content/uploads/2018/04/818-ep182.png)  ```cpp class Solution { public:     int racecar(int target) {         m_ = vector<int> (target+1,0);         return dp(target);      } private:     vector<int> m_;     int dp(int t){         if(m_[t]>0) return m_[t];         int n = ceil(log2(t+1));         if(1<<n == t+1) return m_[t] = n; //正好target是2的n次方-1          m_[t] = n+1+dp((1<<n) -1-t); //超出后，倒车看dp子问题          for(int m=0;m<n-1;m++){             int cur = (1<<(n-1))-(1<<m); //倒车倒过头了，记录但当前位置             m_[t] = min(m_[t],n+m+1+dp(t-cur));//再正过来求解子问题\t         }         return m_[t];      } }; ```  '},{title:"842. 将数组拆分成斐波那契序列",path:"/posts/842.%20%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97.html",strippedContent:' #### [842. 将数组拆分成斐波那契序列](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/)  给定一个数字字符串 `S`，比如 `S = "123456579"`，我们可以将它分成斐波那契式的序列 `[123, 456, 579]`。  形式上，斐波那契式序列是一个非负整数列表 `F`，且满足：  - `0 <= F[i] <= 2^31 - 1`，（也就是说，每个整数都符合 32 位有符号整数类型）； - `F.length >= 3`； - 对于所有的`0 <= i < F.length - 2`，都有 `F[i] + F[i+1] = F[i+2]` 成立。  另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。  返回从 `S` 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 `[]`。     **示例 1：**  ``` 输入："123456579" 输出：[123,456,579] ```  **示例 2：**  ``` 输入: "11235813" 输出: [1,1,2,3,5,8,13] ```  **示例 3：**  ``` 输入: "112358130" 输出: [] 解释: 这项任务无法完成。 ```  **示例 4：**  ``` 输入："0123" 输出：[] 解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。 ```  **示例 5：**  ``` 输入: "1101111" 输出: [110, 1, 111] 解释: 输出 [11,0,11,11] 也同样被接受。 ```     **提示：**  1. `1 <= S.length <= 200` 2. 字符串 `S` 中只含有数字。  ```cpp class Solution { public:   vector<int> splitIntoFibonacci(string s) {     const int n = s.length();     vector<int> nums;     function<bool(int)> dfs = [&](int pos) {       if (pos == n) return nums.size() >= 3;       int max_len = s[pos] == \'0\' ? 1 : 10;       long num = 0;       long num1 = 0;       for (int i = pos; i < min(pos + max_len, n); ++i) {         num = num * 10 + (s[i] - \'0\');         if (num > INT_MAX) break;         if (nums.size() >= 2) {                        long sum = nums.rbegin()[0];           num1 = nums.rbegin()[1];           sum +=num1;            if (num > sum) break;           else if (num < sum) continue;           // num must equaals to sum.         }         nums.push_back(num);         if (dfs(i + 1)) return true;         nums.pop_back();       }       return false;     };     dfs(0);     return nums;   } }; ```    backtracking, 回溯法的经典题目  关键在于dfs的构造，以及不满足条件的元素集合，通过 nums.pop_back() 进行回溯，不断改变元素长度，模拟过程，进行比较，最后找到答案。'},{title:"860. 柠檬水找零",path:"/posts/860.%20%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html",strippedContent:" ### [860. 柠檬水找零](https://leetcode-cn.com/problems/lemonade-change/)  在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。  顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。  每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。  注意，一开始你手头没有任何零钱。  如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。  **示例 1：**  ``` 输入：[5,5,5,10,20] 输出：true 解释： 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 由于所有客户都得到了正确的找零，所以我们输出 true。 ```  **示例 2：**  ``` 输入：[5,5,10] 输出：true ```  **示例 3：**  ``` 输入：[10,10] 输出：false ```  **示例 4：**  ``` 输入：[5,5,10,10,20] 输出：false 解释： 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 由于不是每位顾客都得到了正确的找零，所以答案是 false。 ```     **提示：**  - `0 <= bills.length <= 10000` - `bills[i]` 不是 `5` 就是 `10` 或是 `20`     ```cpp class Solution { public:     bool lemonadeChange(vector<int>& bills) {         int m5 =0 , m10 =0;                  for(auto i:bills){             switch(i){                 case 5: {m5++;continue;}                 case 10: {m5--; m10++; break;}                 case 20: if(m10>0) m10--,m5--;                         else m5 -= 3;             }             cout<<m5<<endl;             if (m5 < 0) return false;         }         return true;      } }; ```  这个题一定注意循环内的switch中break和continue使用区别：  https://www.cnblogs.com/pcheng/p/9883608.html  continue：直接跳过本次外围for循环，继续下一个for循环的index；  break：仅仅跳出switch语句，依然执行本次for循环 switch外的语句。"},{title:"845. 数组中的最长山脉",path:"/posts/845.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%B1%B1%E8%84%89.html",strippedContent:" #### [845. 数组中的最长山脉](https://leetcode-cn.com/problems/longest-mountain-in-array/)  我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “*山脉”*：  - `B.length >= 3` - 存在 `0 < i < B.length - 1` 使得 `B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]`  （注意：B 可以是 A 的任意子数组，包括整个数组 A。）  给出一个整数数组 `A`，返回最长 *“山脉”* 的长度。  如果不含有 “*山脉”* 则返回 `0`。     **示例 1：**  ``` 输入：[2,1,4,7,3,2,5] 输出：5 解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。 ```  **示例 2：**  ``` 输入：[2,2,2] 输出：0 解释：不含 “山脉”。 ```     **提示：**  1. `0 <= A.length <= 10000` 2. `0 <= A[i] <= 10000`  ```cpp class Solution { public:     int longestMountain(vector<int>& A) {         if(A.empty()) return 0;         if(A.size()<=2) return 0;         int i=0, j=A.size()-1;         int start=0, end = 0;         int flag = 0;         while(i<j && j!=1){             if(A[i]>=A[i+1])                 i++;             if(A[j]>=A[j-1])                  j--;                        if(A[i]<A[i+1] && A[j]<A[j-1]&& i!=j){                 start = i;                 end = j;                 i++;                 j--;                 while(A[i]<A[i+1] && A[j]<A[j-1] || A[i+1] == A[j-1]||A[i]==A[j]){                     if(A[i+1] == A[j-1]||A[i]==A[j]){                         flag = 1;                     return flag? (end - start +1):0; ;                     }                     i++;                     j--;                 }             }         }         return (flag==1)? (end - start +1):0;      } }; ```  上面这是个错误答案，引以为戒， 山峰并不一定对称，所以每次i++，j--这种思路就是错的。这个题各种边界问题很多，我觉得没必要双指针 ，反而弄麻烦了。就用单指针就OK了：  ```cpp class Solution {     public:      int longestMountain(vector<int> A) {     int start = -1;         int ans = 0;          for (int i = 1; i < A.size(); i++) {             if (A[i - 1] < A[i]) { // 总是在上升阶段，确定山脉起点 start                 if (i == 1 || A[i - 2] >= A[i - 1]) {                     start = i - 1;                 }             } else if (A[i - 1] > A[i]) {                 if (start != -1) {                     ans = max(ans, i - start + 1); // 总是在下降阶段，计算山脉长度                 }              } else {                 start = -1; // 平缓期重置起点             }         }          return ans;     } };   ```  "},{title:"847. 访问所有节点的最短路径",path:"/posts/847.%20%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html",strippedContent:" #### [847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/)  给出 `graph` 为有 N 个节点（编号为 `0, 1, 2, ..., N-1`）的无向连通图。   `graph.length = N`，且只有节点 `i` 和 `j` 连通时，`j != i` 在列表 `graph[i]` 中恰好出现一次。  返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。       **示例 1：**  ``` 输入：[[1,2,3],[0],[0],[0]] 输出：4 解释：一个可能的路径为 [1,0,2,0,3] ```  **示例 2：**  ``` 输入：[[1],[0,2,4],[1,3,4],[2],[1,2]] 输出：4 解释：一个可能的路径为 [0,1,4,2,3] ```     **提示：**  1. `1 <= graph.length <= 12` 2. `0 <= graph[i].length < graph.length`  ```cpp class Solution { public:     int shortestPathLength(vector<vector<int>>& graph)      {         int n = graph.size();         auto visited = vector<vector<bool>>(n,vector<bool>(1<<n,0));                  queue<pair<int,int>>q; // {node, visitedNodes}         for (int i=0; i<n; i++)         {             q.push({i, 1<<i});             visited[i][1<<i] = 1;         }                 int step = -1;         while(!q.empty())         {             step++;             int len = q.size();             while (len--)             {                 int node = q.front().first;                 int state = q.front().second;                 q.pop();                                  for (auto& nextNode:graph[node])                 {                     int nextState = (state | (1<<nextNode));                     if (visited[nextNode][nextState]==1)                         continue;                     if (nextState == (1<<n)-1)                         return step+1;                     q.push({nextNode, nextState});                     visited[nextNode][nextState] = 1;                 }             }                     }                  return 0;              } }; ```    这个题，典型BFS。 需要对每个节点首先压入队列，以及用bool 1<<i 进行标识，然后进行while 队列遍历，对未访问的进行标记，以此类推。   直到访问到最后的结点，返回step+1。 "},{title:"864. 获取所有钥匙的最短路径",path:"/posts/864.%20%E8%8E%B7%E5%8F%96%E6%89%80%E6%9C%89%E9%92%A5%E5%8C%99%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.html",strippedContent:" #### [864. 获取所有钥匙的最短路径](https://leetcode-cn.com/problems/shortest-path-to-get-all-keys/)  给定一个二维网格 `grid`。 `\".\"` 代表一个空房间， `\"#\"` 代表一堵墙， `\"@\"` 是起点，（`\"a\"`, `\"b\"`, ...）代表钥匙，（`\"A\"`, `\"B\"`, ...）代表锁。  我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。  假设 K 为钥匙/锁的个数，且满足 `1 <= K <= 6`，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。  返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 `-1` 。     **示例 1：**  ``` 输入：[\"@.a.#\",\"###.#\",\"b.A.B\"] 输出：8 ```  **示例 2：**  ``` 输入：[\"@..aA\",\"..B#.\",\"....b\"] 输出：6 ```     **提示：**  1. `1 <= grid.length <= 30` 2. `1 <= grid[0].length <= 30` 3. `grid[i][j]` 只含有 `'.'`, `'#'`, `'@'`, `'a'-``'f``'` 以及 `'A'-'F'` 4. 钥匙的数目范围是 `[1, 6]`，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。    ```cpp class Solution { public:     int shortestPathAllKeys(vector<string>& grid)      {         int m = grid.size();         int n = grid[0].size();                  auto visited = vector<vector<unordered_set<int>>>(m,vector<unordered_set<int>>(n));   //二维数组中set标记                  queue<vector<int>>q;  // {x,y,state}         int count = 0;                  for (int i=0; i<m; i++)             for (int j=0; j<n; j++)             {                 if (grid[i][j]=='@')                 {                     q.push({i,j,0});                      visited[i][j].insert(0); //set中加入状态                  }                                      else if (grid[i][j]>='a' && grid[i][j]<='f')                     count++;   //这里知道了一共有几把钥匙             }                  int finalState = 0;         for (int i=0; i<count; i++)             finalState |= (1<<i);  //找出最终状态                  int step = -1;         auto dir = vector<pair<int,int>>({{1,0},{-1,0},{0,1},{0,-1}});  //左右上下四个步伐                           while (!q.empty())         {             step++;                          int len = q.size();                         while (len--)             {                 int x = q.front()[0];                 int y = q.front()[1];                 int state = q.front()[2]; // 三元组索引                 q.pop();                                  for (int k=0; k<4; k++)                 {                     int i = x + dir[k].first;                     int j = y + dir[k].second;                     int newState = state;                                          if (i<0||i>=m||j<0||j>=n) //超出数组边界，出圈了，continue                         continue;                     if (grid[i][j]=='#')// 撞墙了， continue                          continue;                     if (grid[i][j]>='A' && grid[i][j]<='F' && ((state>>(grid[i][j]-'A'))&1)==0)  //是A-F中的一个数， 那么他是锁，不是钥匙                         continue;                                          if (grid[i][j]>='a' && grid[i][j]<='f') // 是钥匙                         newState |= (1<<(grid[i][j]-'a')); // 钥匙状态标记为已取得                                          if (visited[i][j].find(newState)!=visited[i][j].end())                         continue; //如果这set里找到了，continue，没有则继续下面的                                          if (newState == finalState)                         return step+1; //状态是最终状态，那么就可以返回了                                          q.push({i,j,newState});  //加入队列                     visited[i][j].insert(newState);//标记状态                                  }             }                      }                  return -1;     } }; ```    经典while BFS， 围绕着 钥匙的加入队列， 与标记状态展开，对于所有元素 的BFS展开。 "},{title:"874. 模拟行走机器人",path:"/posts/874.%20%E6%A8%A1%E6%8B%9F%E8%A1%8C%E8%B5%B0%E6%9C%BA%E5%99%A8%E4%BA%BA.html",strippedContent:" #### [874. 模拟行走机器人](https://leetcode-cn.com/problems/walking-robot-simulation/)  机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：  - `-2`：向左转 90 度 - `-1`：向右转 90 度 - `1 <= x <= 9`：向前移动 `x` 个单位长度  在网格上有一些格子被视为障碍物。  第 `i` 个障碍物位于网格点  `(obstacles[i][0], obstacles[i][1])`  机器人无法走到障碍物上，它将会停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。  返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。     **示例 1：**  ``` 输入: commands = [4,-1,3], obstacles = [] 输出: 25 解释: 机器人将会到达 (3, 4) ```  **示例 2：**  ``` 输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]] 输出: 65 解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处 ```     **提示：**  1. `0 <= commands.length <= 10000` 2. `0 <= obstacles.length <= 10000` 3. `-30000 <= obstacle[i][0] <= 30000` 4. `-30000 <= obstacle[i][1] <= 30000` 5. 答案保证小于 `2 ^ 31`    ```cpp class Solution { public:     int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {         int direx[] = {0,1,0,-1};         int direy[] = {1,0,-1,0};         int curdir = 0;         int curx=0, cury =0;         int ans = 0;          set<pair<int,int>> obstaclesSet;         for(int i=0;i<obstacles.size();i++)             obstaclesSet.insert(make_pair(obstacles[i][0],obstacles[i][1]));                  for(int i=0;i<commands.size();i++){             if(commands[i]==-1)                 curdir = (curdir + 1)%4;             else if(commands[i]==-2)                 curdir = (curdir +3)%4;             else{                 for (int j=0;j<commands[i];j++){                     int nx = curx + direx[curdir];                     int ny = cury + direy[curdir];                     //cout<<nx-5<<'&'<<ny<<'/'<<curdir<<endl;                     if(obstaclesSet.find(make_pair(nx,ny)) == obstaclesSet.end()){                         curx = nx;                         cury = ny;                         //cout<<nx<<'&'<<ny<<'/'<<endl;                         ans = max(ans,curx*curx+cury*cury);                          }                     else                         break;                  }             }          }         return ans;     } };  ```    这个题调试的时候发现找bug， 发现是因为int curx 没有赋予初始值，导致莫名其妙出了一个奇怪的数。 所以int初始化一定得赋值，有的时候vector<int> 一定要给长度。"},{title:"894. 所有可能的满二叉树",path:"/posts/894.%20%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html",strippedContent:" #### [894. 所有可能的满二叉树](https://leetcode-cn.com/problems/all-possible-full-binary-trees/)  *满二叉树*是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。  返回包含 `N` 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。  答案中每个树的每个`结点`都**必须**有 `node.val=0`。  你可以按任何顺序返回树的最终列表。     **示例：**  ``` 输入：7 输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]] 解释： ```     **提示：**  - `1 <= N <= 20`  ```cpp /**  * Definition for a binary tree node.  * struct TreeNode {  *     int val;  *     TreeNode *left;  *     TreeNode *right;  *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}  * };  */ class Solution { public:     vector<TreeNode*> allPossibleFBT(int N) {         if(N%2 == 0) return {};         if(N ==1 )return {new TreeNode(0)};         vector<TreeNode*> ans;         for(int i=1;i<N;i+=2){             for(auto l:allPossibleFBT(i))                 for(auto r:allPossibleFBT(N-i-1)){                     auto root = new TreeNode(0);                     root->left = l;                     root->right = r;                     ans.push_back(root);                 }          }         return ans;      } }; ```  "},{title:"928.尽量减少恶意软件的传播 II",path:"/posts/928.%E5%B0%BD%E9%87%8F%E5%87%8F%E5%B0%91%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD%20II.html",strippedContent:" 928. 尽量减少恶意软件的传播 II  (这个问题与 尽量减少恶意软件的传播 是一样的，不同之处用粗体表示。)  在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。  一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。  假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。  我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。     示例 1：  输出：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1] 输入：0  示例 2：  输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1] 输出：1  示例 3：  输入：graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1] 输出：1     提示：      1 < graph.length = graph[0].length <= 300     0 <= graph[i][j] == graph[j][i] <= 1     graph[i][i] = 1     1 <= initial.length < graph.length     0 <= initial[i] < graph.length   ```cpp class Solution { public:     int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial)      {         int N = graph.size();         vector<vector<int>>sources(N); // node -> vector of adjacent infection sources         unordered_set<int>initials(initial.begin(),initial.end());                  vector<vector<int>>nextNodes(N); //找出相连结点          for (int i=0; i<N; i++)             for (int j=0; j<N; j++)                 if (i!=j && graph[i][j]==1)                 {                     nextNodes[i].push_back(j);                     nextNodes[j].push_back(i);                 }                              for (int start: initial) //从源头开始找最大的扩散         {             queue<pair<int,int>>q;             q.push({start,start});             unordered_set<int>visited;             visited.insert(start);                          while (!q.empty())             {                 int cur = q.front().first;                 int source = q.front().second;                 q.pop();                              for (auto next: nextNodes[cur])                 {                     if (visited.find(next)!=visited.end())                         continue;                     if (initials.find(next)!=initials.end())                         continue;                                          sources[next].push_back(source);//将source加入该结点                                          q.push({next,source});                     visited.insert(next);                 }             }                     }                  unordered_map<int,int>count; // source -> how many nodes can be reached         for (auto x: sources)           {             if (x.size()==1) //如果只有一个传染源              {                 int s = x[0]; //取出该传染源                 count[s] += 1; //对该传染源进行计数 。。 所得为该传染源领接的结点数目             }         }                  int size = 0;         int ret = -1;         for (auto x: count)         {             if (x.second > size) //传染源领接的结点数目大于size             {                 ret = x.first;                 size = x.second;             }             else if (x.second == size && x.first < ret)                 ret = x.first; //如果size相等，那么就取序号排在前面的传染源         }                  if (ret==-1)  //如果没被改变，那么就直接把传染源排序输出第一个         {             sort(initial.begin(),initial.end());             return initial[0];         }         else //否则直接返回              return ret;              } }; ```  "},{title:"934. 最短的桥",path:"/posts/934.%20%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5.html",strippedContent:" #### [934. 最短的桥](https://leetcode-cn.com/problems/shortest-bridge/)  在给定的二维二进制数组 `A` 中，存在两座岛。（岛是由四面相连的 `1` 形成的一个最大组。）  现在，我们可以将 `0` 变为 `1`，以使两座岛连接起来，变成一座岛。  返回必须翻转的 `0` 的最小数目。（可以保证答案至少是 1。）     **示例 1：**  ``` 输入：[[0,1],[1,0]] 输出：1 ```  **示例 2：**  ``` 输入：[[0,1,0],[0,0,0],[0,0,1]] 输出：2 ```  **示例 3：**  ``` 输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]] 输出：1 ```     **提示：**  1. `1 <= A.length = A[0].length <= 100` 2. `A[i][j] == 0` 或 `A[i][j] == 1`     ```cpp class Solution { public:     int shortestBridge(vector<vector<int>>& A) {         queue<pair<int,int>> q;         bool found = false;         for(int i=0;i<A.size() && !found;i++)             for(int j=0;j<A[0].size() && !found;j++)                 if(A[i][j]){                     dfs(A,i,j,q);                     found = true;                 }          int steps = 0;         vector<int> dirs{0,1,0,-1,0};         while(!q.empty()){             int size = q.size();             while(size --){                 int x = q.front().first;                 int y = q.front().second;                 q.pop();                 for(int i=0;i<4;i++){                     int tx = x+dirs[i];                     int ty = y+dirs[i+1];                     if(tx<0|| ty<0||tx>=A.size()||ty>=A[0].size()||A[tx][ty]==2)                          continue;                     if(A[tx][ty]==1) return steps;                     A[tx][ty] = 2;                     q.emplace(tx,ty);                 }              }             steps++;         }         return -1;     } private:     void dfs(vector<vector<int>>& A,int x,int y, queue<pair<int,int>>& q){         if(x<0 || y<0 || x>=A.size()||y>=A[0].size()||A[x][y] !=1){             return;         }         A[x][y] = 2;         q.emplace(x,y);         dfs(A,x-1,y,q);         dfs(A,x,y-1,q);         dfs(A,x+1,y,q);         dfs(A,x,y+1,q);     } }; ```   经典dfs+bfs结合。   基本上是两个的模板平在一起。 dfs的时候记得所有的第一次找到的那个岛屿都要标记成2；  之后bfs拓展的时候，所有访问到的0的海面也标记成2，直到最后找到1；  这个题目设定只有两个岛屿，所以找到了就可以返回了。"},{title:"998. 最大二叉树 II",path:"/posts/998.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91%20II.html",strippedContent:" #### [998. 最大二叉树 II](https://leetcode-cn.com/problems/maximum-binary-tree-ii/)  最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。  给出最大树的根节点 `root`。  就像[之前的问题](https://leetcode-cn.com/problems/maximum-binary-tree/)那样，给定的树是从表 `A`（`root = Construct(A)`）递归地使用下述 `Construct(A)` 例程构造的：  - 如果 `A` 为空，返回 `null` - 否则，令 `A[i]` 作为 A 的最大元素。创建一个值为 `A[i]` 的根节点 `root` - `root` 的左子树将被构建为 `Construct([A[0], A[1], ..., A[i-1]])` - `root` 的右子树将被构建为 `Construct([A[i+1], A[i+2], ..., A[A.length - 1]])` - 返回 `root`  请注意，我们没有直接给定 A，只有一个根节点 `root = Construct(A)`.  假设 `B` 是 `A` 的副本，并附加值 `val`。保证 `B` 中的值是不同的。  返回 `Construct(B)`。     **示例 1：**  **![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-1.png)![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-2.png)**  ``` 输入：root = [4,1,3,null,null,2], val = 5 输出：[5,4,null,1,3,null,null,2] 解释：A = [1,4,2,3], B = [1,4,2,3,5] ```  **示例 2：  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-1.png)![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-2.png)**  ``` 输入：root = [5,2,4,null,1], val = 3 输出：[5,2,4,null,1,null,3] 解释：A = [2,1,5,4], B = [2,1,5,4,3] ```  **示例 3：  ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-1.png)![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-2.png)**  ``` 输入：root = [5,2,3,null,1], val = 4 输出：[5,2,4,null,1,3] 解释：A = [2,1,5,3], B = [2,1,5,3,4] ```     **提示：**  1. `1 <= B.length <= 100`    ```cpp /**  * Definition for a binary tree node.  * struct TreeNode {  *     int val;  *     TreeNode *left;  *     TreeNode *right;  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}  * };  */ class Solution { public:   TreeNode* insertIntoMaxTree(TreeNode* root, int val) {       if(root && root->val > val){           root->right = insertIntoMaxTree(root->right,val);           return root;       }       TreeNode* new_node = new TreeNode(val);       new_node->left = root;       return new_node;   } }; ```    这里的递归，有点味道。 尤其是针对示例2，仔细品。 那个new_node->left = root; ，由于root是NULL， 返回就返回这个新添加的结点。   妙！"},{title:"56. Merge Intervals",path:"/posts/56.%20Merge%20Intervals.html",strippedContent:" ##56. Merge Intervals  Medium  Given a collection of intervals, merge all overlapping intervals.  **Example 1:**  ``` Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. ```  **Example 2:**  ``` Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. ```  **NOTE:** input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.     **Constraints:**  - `intervals[i][0] <= intervals[i][1]`    这个是开始写的怎么都调不对的代码：  ```cpp class Solution { public:     vector<vector<int>> merge(vector<vector<int>>& intervals) {         vector<vector<int>> result;         sort(intervals.begin(),intervals.end(),[](vector<int> a,vector<int> b){             return (a[0]<b[0] || a[0]==b[0] && a[1]<=b[1]);         });         int flag = 0;           if (intervals.size()==1){             result = intervals;                      }         else{             for(int i=0;i<intervals.size();i++){             if(i==intervals.size()-1){                 if(!flag)                     result.push_back(intervals[i]);             }             else{                  if(intervals[i][1]>=intervals[i+1][0]){                                     result.push_back({intervals[i][0],intervals[i+1][1]});                     i++;                     if(i==intervals.size()-2){                         flag = 1;                     }             }             else{                 result.push_back(intervals[i]);             }             }         }          }         return result;     } }; ```  问题的原因在于没有用back()函数，直接读取vector<int> ans中最后一个元素进行比较，这样就能避免两个两个配对比较的index对不齐的坑跌状况;  ```cpp class Solution { public:     vector<vector<int>> merge(vector<vector<int>>& intervals) {         if (intervals.empty()) return {};                  std::sort(intervals.begin(), intervals.end(),                    [](const vector<int> a, const vector<int> b){                         return a[0] < b[0];                     });                  vector<vector<int>> ans;                 for (const auto& interval : intervals) {             if (ans.empty() || interval[0] > ans.back()[1]) {                 ans.push_back(interval);             } else {                 ans.back()[1] = max(ans.back()[1], interval[1]);             }         }         return ans;     } };  ```  这里面 用for (const auto& interval : intervals) ，值得学习;  ans.back()可以直接拿来比较，这样也不会出现没有比较遗漏element的状况。   "},{title:"Merge Intervals_back()函数",path:"/posts/56.%20Merge%20Intervals_back()%E5%87%BD%E6%95%B0.html",strippedContent:"## 56. Merge Intervals   Medium  Given a collection of intervals, merge all overlapping intervals.  **Example 1:**  ``` Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. ```  **Example 2:**  ``` Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. ```  **NOTE:** input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.     **Constraints:**  - `intervals[i][0] <= intervals[i][1]`    这个是开始写的怎么都调不对的代码：  ```cpp class Solution { public:     vector<vector<int>> merge(vector<vector<int>>& intervals) {         vector<vector<int>> result;         sort(intervals.begin(),intervals.end(),[](vector<int> a,vector<int> b){             return (a[0]<b[0] || a[0]==b[0] && a[1]<=b[1]);         });         int flag = 0;           if (intervals.size()==1){             result = intervals;                      }         else{             for(int i=0;i<intervals.size();i++){             if(i==intervals.size()-1){                 if(!flag)                     result.push_back(intervals[i]);             }             else{                  if(intervals[i][1]>=intervals[i+1][0]){                                     result.push_back({intervals[i][0],intervals[i+1][1]});                     i++;                     if(i==intervals.size()-2){                         flag = 1;                     }             }             else{                 result.push_back(intervals[i]);             }             }         }          }         return result;     } }; ```  问题的原因在于没有用back()函数，直接读取vector<int> ans中最后一个元素进行比较，这样就能避免两个两个配对比较的index对不齐的坑跌状况;  ```c++ class Solution { public:     vector<vector<int>> merge(vector<vector<int>>& intervals) {         if (intervals.empty()) return {};                  std::sort(intervals.begin(), intervals.end(),                    [](const vector<int> a, const vector<int> b){                         return a[0] < b[0];                     });                  vector<vector<int>> ans;                 for (const auto& interval : intervals) {             if (ans.empty() || interval[0] > ans.back()[1]) {                 ans.push_back(interval);             } else {                 ans.back()[1] = max(ans.back()[1], interval[1]);             }         }         return ans;     } };  ```  这里面 用for (const auto& interval : intervals) ，值得学习;  ans.back()可以直接拿来比较，这样也不会出现没有比较遗漏element的状况。"},{title:"134. Gas Station",path:"/posts/134.%20Gas%20Station.html",strippedContent:" ##134. Gas Station  Medium  There are *N* gas stations along a circular route, where the amount of gas at station *i* is `gas[i]`.  You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from station *i* to its next station (*i*+1). You begin the journey with an empty tank at one of the gas stations.  Return the starting gas station's index if you can travel around the  circuit once in the clockwise direction, otherwise return -1.  **Note:**  - If there exists a solution, it is guaranteed to be unique. - Both input arrays are non-empty and have the same length. - Each element in the input arrays is a non-negative integer.  **Example 1:**  ``` Input:  gas  = [1,2,3,4,5] cost = [3,4,5,1,2]  Output: 3  Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. ```  **Example 2:**  ``` Input:  gas  = [2,3,4] cost = [3,4,3]  Output: -1  Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. ```      ```cpp class Solution { public:     int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {                  int rest = 0;         int n = gas.size();         int p = 0;         int q = 1;         int flag = 0;         for (int j=0;j<n;j++){             gas.push_back(gas[j]);             cost.push_back(cost[j]);         }         int d = gas.size();         for (int i= 0; i<d;i++){                          if (gas[i]+rest-cost[i]>=0){                 rest += gas[i]-cost[i];                 q++;                 if(q==n+1){                     p = i;                     //q = m;                     flag = 1;                     break;                    }                                         }              else{                 q = 1;                 rest = 0;             }         }         if (flag)             return p-q+2;         else return -1;              } }; ```      把数组拓展去做;"},{title:"166. Fraction to Recurring Decimal",path:"/posts/166.%20Fraction%20to%20Recurring%20Decimal.html",strippedContent:' ##166. Fraction to Recurring Decimal  Medium  Given two integers representing the `numerator` and `denominator` of a fraction, return *the fraction in string format*.  If the fractional part is repeating, enclose the repeating part in parentheses.  If multiple answers are possible, return **any of them**.     **Example 1:**  ``` Input: numerator = 1, denominator = 2 Output: "0.5" ```  **Example 2:**  ``` Input: numerator = 2, denominator = 1 Output: "2" ```  **Example 3:**  ``` Input: numerator = 2, denominator = 3 Output: "0.(6)" ```  **Example 4:**  ``` Input: numerator = 4, denominator = 333 Output: "0.(012)" ```  **Example 5:**  ``` Input: numerator = 1, denominator = 5 Output: "0.2" ```     **Constraints:**  - `-231 <= numerator, denominator <= 231 - 1` - `denominator != 0`    ```cpp class Solution { public:     string fractionToDecimal(int numerator, int denominator)      {         long A = numerator;         long B = denominator;                  if (A==0) return "0";                  int sign = 1;         if (A<0)         {             sign *= -1;             A = abs(A);         }         if (B<0)         {             sign *= -1;             B = abs(B);         }                  string ret;         if (sign==-1) ret = "-";                  ret += to_string(A/B);                  if (A%B==0) return ret; //完全可以整除，没有小数部分；         else ret+=".";                  long C = A%B;                  unordered_map<int,int>Map;                  while (C!=0 && Map.find(C)==Map.end()) //这里是长除；         {             Map[C] = ret.size(); //  每次需要更新Map的长度 ，最后保存的是前面所有非循环部分的长度；             ret.push_back(\'0\'+C*10/B);//这里有‘0’， 因为C×10 有除以B 为零的情况             C = C*10%B;          }                  if (C==0) return ret;  //如果结果不循环；              ret.insert(ret.begin()+Map[C], \'(\');  //处理循环部分的结果，这里+Map[C]就是找到从ret开始到Map[C]的位置，从而让这里这个左括号加在循环体左边；         ret.push_back(\')\');                  return ret;     } }; ```      '},{title:"142. Linked List Cycle II",path:"/posts/142.%20Linked%20List%20Cycle%20II.html",strippedContent:" ##142. Linked List Cycle II  Medium  Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.  There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.  **Notice** that you **should not modify** the linked list.  **Follow up:**  Can you solve it using `O(1)` (i.e. constant) memory?     **Example 1:**  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)  ``` Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. ```  **Example 2:**  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)  ``` Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. ```  **Example 3:**  ![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)  ``` Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. ```     **Constraints:**  - The number of the nodes in the list is in the range `[0, 104]`. - `-105 <= Node.val <= 105` - `pos` is `-1` or a **valid index** in the linked-list.    ```cpp /**  * Definition for singly-linked list.  * struct ListNode {  *     int val;  *     ListNode *next;  *     ListNode(int x) : val(x), next(NULL) {}  * };  */ class Solution { public:     ListNode *detectCycle(ListNode *head)      {         if(head==NULL) return NULL;         ListNode* slow = head;         ListNode* fast = head;         bool ret=false;         while(fast->next!=NULL)         {             fast = fast->next;             slow = slow->next;             if(fast->next==NULL) return NULL; //判断这里有没有空指针指针，因为slow比fast慢，所以在后面走fast走过的路径，不用检测；             fast = fast->next;             if(fast==slow) //这里两指针相遇了；             {                 ret = true; //标志位置1；                 break;              }         }         if(ret==false) return NULL;          slow = head; //重置慢指针到头结点；         while(slow!=fast)         {             slow = slow->next;             fast = fast->next;         }         return slow;     } }; ```    这道题目是经典的快慢指针问题，也叫做Floy's algorithm。   思想是： 快指针是慢指针速度的两倍，同时开始，直到相遇；此时，慢指针重置到开头，快指针从相遇处继续，让快指针变成和慢指针一样的速度，那么他们再次相遇的地方就是环的起点。    ![image-20200928171402861](/home/viktor/.config/Typora/typora-user-images/image-20200928171402861.png)  "},{title:"Insert Interval",path:"/posts/57.%20Insert%20Interval.html",strippedContent:"\\57. Insert Interval  Medium  Given a set of *non-overlapping* intervals, insert a new interval into the intervals (merge if necessary).  You may assume that the intervals were initially sorted according to their start times.     **Example 1:**  ``` Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] ```  **Example 2:**  ``` Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. ```  **Example 3:**  ``` Input: intervals = [], newInterval = [5,7] Output: [[5,7]] ```  **Example 4:**  ``` Input: intervals = [[1,5]], newInterval = [2,3] Output: [[1,5]] ```  **Example 5:**  ``` Input: intervals = [[1,5]], newInterval = [2,7] Output: [[1,7]] ```     **Constraints:**  - `0 <= intervals.length <= 104` - `intervals[i].length == 2` - `0 <= intervals[i][0] <= intervals[i][1] <= 105` - `intervals` is sorted by `intervals[i][0]` in **ascending** order. - `newInterval.length == 2` - `0 <= newInterval[0] <= newInterval[1] <= 105`    ```cpp class Solution { public:     vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {             auto it = intervals.begin();         while (it != intervals.end() && newInterval[0] > (*it)[0]) ++it;//这里一定要注意，×it传的是值，对他索引时要带括号;         intervals.insert(it, newInterval);                  // Merge intervals without sorting         vector<vector<int>> ans;                 for (const auto& interval : intervals) {             if (ans.empty() || interval[0] > ans.back()[1]) {                 ans.push_back(interval);             } else {                 ans.back()[1] = max(ans.back()[1], interval[1]);             }         }                  return ans;     } };  ```    这个题主要是对于iterator的用法，   while (it != intervals.end() && newInterval[0] > (*it)[0]) ++it; 这句话写的 1.遍历 2.找到合适位置停下  然后insert， 没毛病;  这个题insert的newInterval就一个，所以就这么写了，没问题;    I'm sure you know that a `std::vector<X>` stores a whole bunch of `X` objects, right? But if you have a `std::map<X, Y>`, what it actually stores is a whole bunch of `std::pair<const X, Y>`s. That's exactly what a map is - it pairs together the keys and the associated values.  When you iterate over a `std::map`, you're iterating over all of these `std::pair`s. When you dereference one of these iterators, you get a `std::pair` containing the key and its associated value.  这里意思是如果是map，或者std::pair, 他们是可以（×it）.first .second 这样索引的，而这里没有，这里只有二维数组，所以只能直接index。  std::map<X, Y>实际储存了一串std::pair<const X, Y>  std::map<std::string, int> m = /* fill it */;  auto it = m.begin();  这里，如果你用*it，那么你将得到map第一个元素的std::pair：  现在你可以接收std::pair的两个元素：  (*it).first会得到key，  (*it).second会得到value。  这等同于it->first和it->second。"},{title:"柱状图中最大的矩形_堆栈",path:"/posts/84.%20%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2_%E5%A0%86%E6%A0%88.html",strippedContent:"#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)  给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。  求在该柱状图中，能够勾勒出来的矩形的最大面积。     ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)  以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。     ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)  图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。     **示例:**  ``` 输入: [2,1,5,6,2,3] 输出: 10 ```      ```cpp class Solution { public:     int largestRectangleArea(vector<int>& heights) {            int ans = 0;     vector<int> st;     heights.insert(heights.begin(), 0);     heights.push_back(0);     for (int i = 0; i < heights.size(); i++)     {         while (!st.empty() && heights[st.back()] > heights[i])         {             int cur = st.back();             st.pop_back();             int left = st.back() + 1;             int right = i - 1;             ans = max(ans, (right - left + 1) * heights[cur]);         }         st.push_back(i);     }     return ans;              } }; ```    这个题关键在于堆栈的使用，在用堆栈前，对数据进行了前后补零处理。    ```cpp //堆栈模板： for (int i = 0; i < heights.size(); i++)     {         while (!st.empty() && heights[st.back()] > heights[i])         {         st.pop_back()；         }                  st.push_back(i); ```  "},{title:"Nth Digit",path:"/posts/400.Nth%20Digit.html",strippedContent:"##400.Nth Digit  Medium  Find the *n*th digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...   **Note:**  *n* is positive and will fit within the range of a 32-bit signed integer (*n* < 231).  **Example 1:**  ``` Input: 3  Output: 3 ```    **Example 2:**  ``` Input: 11  Output: 0  Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10. ```    ```cpp class Solution { public:     int findNthDigit(int N)      {         int k = 0;         long n = N;// n这里本身就是数的index，用long存防止不够减          long nums = 0;         while (n > 0)         {                     k++;                 nums = kDigitNums(k);             n -= nums;  //每次减去k位数占的位置         }          if (n==0) return 9;  //因为k=1时，nums = 9,k=2时， nums = 180, 如果这里这里整除了，那么那个n位一定是9；          n += nums; //跳出循环，加上刚才减掉的nums；         int m = n/k;  //记录n是在k位数的第m个；         if (n%k==0) m--; //如果余数是0,那么它应是前一个数         int r = n%k;//记录他是第m个数的第r位         if (r==0) r=k;          int ret = pow(10,k-1) + m; //记录该数的总位置          return to_string(ret)[r-1] - '0'; //返回该数的的第r-1位，因为是与0作差；     }      long kDigitNums(int k)     {         return  (pow(10, k) - pow(10, k-1)) * k; //算k位数一共占了多少位置     } };  ```  "},{title:"Queue Reconstruction by Height_sort与insert",path:"/posts/406.%20Queue%20Reconstruction%20by%20Height_sort%E4%B8%8Einsert.html",strippedContent:"\\##406. Queue Reconstruction by Height  Medium  Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers `(h, k)`, where `h` is the height of the person and `k` is the number of people in front of this person who have a height greater than or equal to `h`. Write an algorithm to reconstruct the queue.  **Note:**  The number of people is less than 1,100.  **Example**  ``` Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]  Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] ```     ```cpp class Solution { public:     vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {         vector<vector<int>> result;         sort (people.begin(),people.end(),[](const vector<int>& a, const vector<int>& b ){         return (a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]));         });                  for (vector<int> x: people)             result.insert(result.begin() + x[1],x);                  return result;                       } }; ```    这个题目关键在于 sort的operator写法，首先按照 height从大到小， 顺序从小到大的复合顺序进行排列;  然后for一个(vector<int> x: people)  ，这里堆people里的元素指定类型操作， 用到了vector<int> 的insert，  这里result.begin()就从头插入，加[x]就是加上位置顺序。"},{title:"Longest Repeating Character Replacement_滑窗问题",path:"/posts/424.%20Longest%20Repeating%20Character%20Replacement_%E6%BB%91%E7%AA%97%E9%97%AE%E9%A2%98.html",strippedContent:"\\##424. Longest Repeating Character Replacement  Medium  Given a string `s` that consists of only uppercase English letters, you can perform at most `k` operations on that string.  In one operation, you can choose **any** character of the string and change it to any other uppercase English character.  Find the length of the longest sub-string containing all repeating letters you can get after performing the above operations.  **Note:**  Both the string's length and *k* will not exceed 104.  **Example 1:**  ``` Input: s = \"ABAB\", k = 2  Output: 4  Explanation: Replace the two 'A's with two 'B's or vice versa. ```     **Example 2:**  ``` Input: s = \"AABABBA\", k = 1  Output: 4  Explanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\". The substring \"BBBB\" has the longest repeating letters, which is 4. ```      ```cpp class Solution { public:     int characterReplacement(string s, int k) {         int low = 0;         unordered_map<char,int> m_;         int most_frequent_count;         int maxLength = 0;         for (int high = 0;high <s.length(); high++){            int current_char_count = ++m_[s[high]];     most_frequent_count=max(most_frequent_count,current_char_count);             while(high -low +1 -most_frequent_count > k){                 m_[s[low]]--;                 low++;                }                          maxLength = max(most_frequent_count,high-low+1);         }                 return maxLength;     } }; ```    这个题是经典的sliding window。  sliding window的一个模板：  ```c++ int low = 0;  for (int high = 0;high <s.length(); high++){ //开始时high 与 low都为0, 以high增加写for循环;  \twhile(high -low +1 -most_frequent_count > k){//用来控制滑窗，1.low向上移动，2.pop掉移动所抛弃的element;                 m_[s[low]]--;                     low++;  \t }  \tmaxLength = max(maxLength, low - high +1);   return maxLength;    ```  "},{title:"436. Find Right Interval",path:"/posts/436.%20Find%20Right%20Interval.html",strippedContent:" ##436. Find Right Interval  Medium  You are given an array of `intervals`, where `intervals[i] = [starti, endi]` and each `starti` is **unique**.  The **r****ight** **interval** for an interval `i` is an interval `j` such that `startj`` >= endi` and `startj` is **minimized**.  Return *an array of **right interval** indices for each interval `i`*. If no **right interval** exists for interval `i`, then put `-1` at index `i`.     **Example 1:**  ``` Input: intervals = [[1,2]] Output: [-1] Explanation: There is only one interval in the collection, so it outputs -1. ```  **Example 2:**  ``` Input: intervals = [[3,4],[2,3],[1,2]] Output: [-1,0,1] Explanation: There is no right interval for [3,4]. The right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3. The right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2. ```  **Example 3:**  ``` Input: intervals = [[1,4],[2,3],[3,4]] Output: [-1,2,-1] Explanation: There is no right interval for [1,4] and [3,4]. The right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3. ```     **Constraints:**  - `1 <= intervals.length <= 2 * 104` - `intervals[i].length == 2` - `-106 <= starti <= endi <= 106` - The start point of each interval is **unique**.    ```cpp class Solution {    public:     vector<int> findRightInterval(vector<vector<int>>& intervals) {         vector<pair<pair<int, int>, int>> sorted;         int n = intervals.size();         for(int i = 0; i < n; ++i)             sorted.push_back({{intervals[i][0], intervals[i][1]}, i});         sort(sorted.begin(), sorted.end());                  vector<int> result(n, -1);         for(int i = 0; i < n; ++i)             result[i] = binary_search(sorted, intervals[i][1]);                  return result;     }   private:     int binary_search(vector<pair<pair<int, int>, int>>& sorted, int x){         int n = sorted.size();         if(sorted[n-1].first.first < x) return -1;                  int l = 0, r = n-1;         while(l <= r){             int mid = l + (r-l)/2;             if(sorted[mid].first.first >= x) r = mid-1; //括号里是条件，一定得有mid             else l = mid+1;         }         return sorted[l].second;     } };  ```      这是一道经典的二分搜索  二分搜索左l=0, 右一边设置为 n  mid = l+（r-l）/2;  然后有个判断条件，括号里一定有mid    随后根据mid的判断条件条件将 l 或 r 进行移动   r = mid+1 ； 或 l = mid + 1;  "},{title:"First Missing Positive",path:"/posts/41.%20First%20Missing%20Positive.html",strippedContent:'\\##41. First Missing Positive  Hard  Given an unsorted integer array, find the smallest missing positive integer.  **Example 1:**  ``` Input: [1,2,0] Output: 3 ```  **Example 2:**  ``` Input: [3,4,-1,1] Output: 2 ```  **Example 3:**  ``` Input: [7,8,9,11,12] Output: 1 ```  **Follow up:**  Your algorithm should run in *O*(*n*) time and uses constant extra space.      ```c++  class Solution { public:     int firstMissingPositive(vector<int>& nums) {         unordered_map<int,int> map;         sort(nums.begin(),nums.end());         int n = nums.size();         int m = 1;         for (int i=0; i<n;i++){             if(nums[i]>0  ){                                  if(nums[i] == m && !map.count(nums[i])){                     map[nums[i]]= i;                     m++;}                 else if (nums[i] != m && map.count(nums[i]))                     continue;                  else                     break;                    }                      }         return m;     } }; ```    这个题注意的是需要记忆hashmap每次赋值方式：  ​                 一共有三种：  ```cpp   \t\t1. 直接赋值：map[nums[i]]= i;    \t\t2.\templace：for (const auto& c : favoriteCompanies)     \t\t \tm.emplace_back(begin(c), end(c))                          ret = umap.emplace("STL教程", "http://c.biancheng.net/stl/");                       3.  std::pair<string, string>mypair("STL教程", "http://c.biancheng.net/stl/");     \t\t//创建接收 insert() 方法返回值的pair类型变量     \t\tstd::pair<unordered_map<string, string>::iterator, bool> ret;     \t\t//调用 insert() 方法的第一种语法格式    \t\t\t ret = umap.insert(mypair);             //向 umap 容器同时添加多个键值对             umap.insert({ {"STL教程","http://c.biancheng.net/stl/"},             {"Python教程","http://c.biancheng.net/python/"},             {"Java教程","http://c.biancheng.net/java/"} }); ```    ##### 元素查找  ```C++ unordered_map<char, int>::iterator it; it = unorderedFirst.find(\'a\');   //返回查找到元素的iterator，如未查找到，返回end()  if (it != unorderedFirst.end()) { \tcout << (*it).first << " " << (*it).second << endl; }  int n; n = unorderedFirst.count(\'z\');  //测试某个关键字是否存在  cout << n << endl; ```'},{title:"496. Next Greater Element I_标志位+find()",path:"/posts/496.%20Next%20Greater%20Element%20I_%E6%A0%87%E5%BF%97%E4%BD%8D+find().html",strippedContent:"\\##496. Next Greater Element I  Easy  You are given two arrays **(without duplicates)** `nums1` and `nums2` where `nums1`’s elements are subset of `nums2`. Find all the next greater numbers for `nums1`'s elements in the corresponding places of `nums2`.   The Next Greater Number of a number **x** in `nums1` is the first greater number to its right in `nums2`. If it does not exist, output -1 for this number.  **Example 1:**  ``` Input: nums1 = [4,1,2], nums2 = [1,3,4,2]. Output: [-1,3,-1] Explanation:     For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.     For number 1 in the first array, the next greater number for it in the second array is 3.     For number 2 in the first array, there is no next greater number for it in the second array, so output -1. ```    **Example 2:**  ``` Input: nums1 = [2,4], nums2 = [1,2,3,4]. Output: [3,-1] Explanation:     For number 2 in the first array, the next greater number for it in the second array is 3.     For number 4 in the first array, there is no next greater number for it in the second array, so output -1. ```    **Note:**  1. All elements in `nums1` and `nums2` are unique. 2. The length of both `nums1` and `nums2` would not exceed 1000.    ```cpp class Solution { public:     vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {         vector<int> result;            std::vector<int>::iterator it;         int n = nums1.size();                  for(int i=0;i<n;i++){             int flag = 0;             it = find (nums2.begin(), nums2.end(), nums1[i]);                 while(it !=nums2.end()){                     if (*it>nums1[i]){                         result.push_back(*it);                         flag = 1;                         break;                     }                     it++;                 }                                  if (!flag)                   result.push_back(-1);         }         return result;     }      };   ```    这个题 主要是用到 find()， iterator it ：        std::vector<int>::iterator it;  it = find （begin，end，val）;  另外这里用了flag标记，作为该处是否已经push_back的依据。"},{title:"564. Find the Closest Palindrome",path:"/posts/564.%20Find%20the%20Closest%20Palindrome.html",strippedContent:' \\##564. Find the Closest Palindrome  Hard  Given an integer n, find the closest integer (not including itself), which is a palindrome.   The \'closest\' is defined as absolute difference minimized between two integers.  **Example 1:**  ``` Input: "123" Output: "121" ```    **Note:**  1. The input **n** is a positive integer represented by string, whose length will not exceed 18. 2. If there is a tie, return the smaller one as answer.      ```cpp class Solution { public:string nearestPalindromic(string n) {    if(n.length()==1) return to_string(stoi(n)-1); //Special case for single digit numbers        int digits=n.length();    vector<long>candidates;    candidates.push_back(pow(10,digits-1)-1);//Case 1    candidates.push_back(pow(10,digits)+1);//Case 2     int mid=(digits+1)/2;    long prefix=stol(n.substr(0,mid));    //Case 3    vector<long>v={prefix,prefix+1,prefix-1};    for(long i:v)    {        string postfix=to_string(i);        if(digits%2!=0) postfix.pop_back();// 奇数时去掉最后一位， 然后下一步翻转，此时是string         reverse(postfix.begin(),postfix.end());        string c=to_string(i)+postfix;        candidates.push_back(stol(c));    }    long mindiff=LONG_MAX;long result;long num=stol(n);    for(int i=0;i<5;i++)    {        if(candidates[i]!=num&&abs(candidates[i]-num)<mindiff)//Candidate must not be the same number and abs diff is minm        {            mindiff=abs(candidates[i]-num);            result=candidates[i];        }        else if(abs(candidates[i]-num)==mindiff) result=min(result,candidates[i]);    }     return to_string(result); } }; ```    对于任何可能的数字，有5种情况： 说数字是4723  情况1。下一个最接近的书报馆多一位数：所以这里是10001 情况2。下一个最接近的回文数少一位：所以这里是999 情况3。下一个最接近的回文位数相同 对于情况3，有3个子情况： -中间数字保持不变。后缀是前缀的镜像。所以这里47（前缀）74（后缀）-> 4774 -中间数字增加1.Postfix是前缀的镜像。所以这里4884 -中间数字减少1.Postfix是前缀的镜像。所以这里4664 在这5名候选人中： 与原始数字绝对差最小的候选人是答案。在这种情况下为4774。  '},{title:"592. Fraction Addition and Subtraction",path:"/posts/592.%20Fraction%20Addition%20and%20Subtraction.html",strippedContent:' \\##592. Fraction Addition and Subtraction  Medium  Given a string representing an expression of fraction addition and  subtraction, you need to return the calculation result in string format. The final result should be [irreducible fraction](https://en.wikipedia.org/wiki/Irreducible_fraction). If your final result is an integer, say `2`, you need to change it to the format of fraction that has denominator `1`. So in this case, `2` should be converted to `2/1`.  **Example 1:**  ``` Input:"-1/2+1/2" Output: "0/1" ```    **Example 2:**  ``` Input:"-1/2+1/2+1/3" Output: "1/3" ```    **Example 3:**  ``` Input:"1/3-1/2" Output: "-1/6" ```    **Example 4:**  ``` Input:"5/3+1/3" Output: "2/1" ```    **Note:**  1. The input string only contains `\'0\'` to `\'9\'`, `\'/\'`, `\'+\'` and `\'-\'`. So does the output. 2. Each fraction (input and output) has format `±numerator/denominator`. If the first input fraction or the output is positive, then `\'+\'` will be omitted. 3. The input only contains valid **irreducible fractions**, where the **numerator** and **denominator** of each fraction will always be in the range [1,10]. If the denominator is 1, it means this fraction is actually an integer in a fraction  format defined above. 4. The number of given fractions will be in the range [1,10]. 5. The numerator and denominator of the **final result** are guaranteed to be valid and in the range of 32-bit int.    ```cpp class Solution { public:     string fractionAddition(string expression) {         stringstream s(expression);         int A=0,B=1,a,b;         char c;         while(s>>a>>c>>b){             A=A*b+a*B;             B=b*B;             int g=__gcd(abs(A),abs(B));             A/=g;             B/=g;         }         return to_string(A)+"/"+to_string(B);     } }; ```    这里用了__gcd(x,y) 函数，属于\\#include<algorithm>中的。  greatest common divisor  另外这个题里的stringstream， 也是每次输入一个char字符，从而很好的对字符串进行了录入。    这个题其他leecode答案长度很长，这道题极大简化了。  能简化的原因是，这个题它本质上就是通分    A/B + a/b = (A*b + B*a)/B*b    同分之后，找到最大共有因数，然后A 和 B 同时除以这个 gcd 就行了。   '},{title:"530. Minimum Absolute Difference in BST",path:"/posts/530.%20Minimum%20Absolute%20Difference%20in%20BST.html",strippedContent:" ##530. Minimum Absolute Difference in BST  Easy  Given a binary search tree with non-negative values, find the minimum [absolute difference](https://en.wikipedia.org/wiki/Absolute_difference) between values of any two nodes.  **Example:**  ``` Input:     1     \\      3     /    2  Output: 1  Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). ```     **Note:**  - There are at least two nodes in this BST. - This question is the same as 783: https://leetcode.com/problems/minimum-distance-between-bst-nodes/  ```cpp /**  * Definition for a binary tree node.  * struct TreeNode {  *     int val;  *     TreeNode *left;  *     TreeNode *right;  *     TreeNode() : val(0), left(nullptr), right(nullptr) {}  *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}  *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}  * };  */ class Solution { public:     int getMinimumDifference(TreeNode* root) {         vector<int> sorted;         inorder(root,sorted);         int min_diff = sorted.back();         for (int i=1; i<sorted.size();++i){             min_diff = min(min_diff,sorted[i] - sorted[i-1]);         }                  return min_diff;                                } private:     void inorder(TreeNode* root, std::vector<int> &sorted){         if (!root) return;         inorder(root->left,sorted);         sorted.push_back(root->val);         inorder(root->right,sorted);     } }; ```    二叉查找树有两个属性：  * 所有节点都比左子树中的节点大  * 所有节点都小于右子树中的节点  二分搜索树 可以通过 中序遍历， sort出一个数组。  然后再找出最小差。  中序遍历的写法 递归， 判断是否节点为空，返回； 然后递归左子树，pushback 根结点，再递归右子书。"},{title:"611. Valid Triangle Number",path:"/posts/611.%20Valid%20Triangle%20Number.html",strippedContent:" \\611. Valid Triangle Number  Medium  Given an array consists of non-negative integers,  your task is to count the  number of triplets chosen from the array that can make triangles if we  take them as side lengths of a triangle.  **Example 1:**  ``` Input: [2,2,3,4] Output: 3 Explanation: Valid combinations are:  2,3,4 (using the first 2) 2,3,4 (using the second 2) 2,2,3 ```    **Note:**  1. The length of the given array won't exceed 1000. 2. The integers in the given array are in the range of [0, 1000].    ```cpp class Solution { public:     int triangleNumber(vector<int>& nums) {         if (nums.size() < 3) return 0;         std::sort(nums.rbegin(), nums.rend());                  int n = nums.size();         int ans = 0;         for (int c = 0; c < n-2; ++c) {                     int b = c + 1;             int a = n - 1;             while (b < a) {                 if (nums[a] + nums[b] > nums[c]) {                     ans += (a - b);                     ++b;                 } else {                     --a;                 }             }         }                  return ans;     } }; ```    ![img](http://zxi.mytechroad.com/blog/wp-content/uploads/2017/09/611-ep43.png)"},{title:"678. Valid Parenthesis String_可选与强制匹配",path:"/posts/678.%20Valid%20Parenthesis%20String_%E5%8F%AF%E9%80%89%E4%B8%8E%E5%BC%BA%E5%88%B6%E5%8C%B9%E9%85%8D.html",strippedContent:" \\##678. Valid Parenthesis String  Medium  Given a string containing only three types of characters: '(', ')' and  '*', write a function to check whether this string is valid. We define  the validity of a string by these rules:  1. Any left parenthesis `'('` must have a corresponding right parenthesis `')'`. 2. Any right parenthesis `')'` must have a corresponding left parenthesis `'('`. 3. Left parenthesis `'('` must go before the corresponding right parenthesis `')'`. 4. `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string. 5. An empty string is also valid.    **Example 1:**  ``` Input: \"()\" Output: True ```    **Example 2:**  ``` Input: \"(*)\" Output: True ```    **Example 3:**  ``` Input: \"(*))\" Output: True ```    **Note:**  1. The string size will be in the range [1, 100].  ```cpp class Solution { public:     bool checkValidString(string s) {         int min_op = 0;         int max_op = 0;                  for (char c:s){             if (c == '(') ++min_op; else --min_op;             if (c != ')') ++max_op; else --max_op;             if (max_op < 0) return false;             min_op = max(0, min_op);                      }         return min_op == 0;              } }; ```    这个题主要在于，强制匹配与可选匹配的一个配置问题。  这里我们可以看到，'(' 采用强制匹配，  min_op<=0时，这个配对是可以的;  ')'采用可选匹配，max_op如果小于0,那说明’）‘ 已经太多了，左边的*都当做左括号也不够用。 "},{title:"630. Course Schedule III_PQ",path:"/posts/630.%20Course%20Schedule%20III_PQ.html",strippedContent:" ## 630. Course Schedule III  Hard  There are `n` different online courses numbered from `1` to `n`. Each course has some duration(course length) `t` and closed on `dth` day. A course should be taken **continuously** for `t` days and must be finished before or on the `dth` day. You will start at the `1st` day.  Given `n` online courses represented by pairs `(t,d)`, your task is to find the maximal number of courses that can be taken.  **Example:**  ``` Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation:  There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day.  Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day.  The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date. ```    **Note:**  1. The integer 1 <= d, t, n <= 10,000. 2. You can't take two courses simultaneously.    ```cpp class Solution {     static bool cmp(vector<int>&a,vector<int>&b)     {         return a[1]<b[1];     } public:     int scheduleCourse(vector<vector<int>>& courses) {         sort(courses.begin(),courses.end(),cmp);             priority_queue<int> pq;         int day = 0;         for(int i=0;i<courses.size();i++){             if(day+courses[i][0]<=courses[i][1]){                 day += courses[i][0];                 pq.push(courses[i][0]);             }             else{                 day += courses[i][0];                 pq.push(courses[i][0]);                 day -=pq.top();                 pq.pop();             }          }         return pq.size();     } }; ```    这个题要注意sort cmp的写法，还可以这么写：（用于比较list中元素第二项大小）  ```c++ sort(courses.begin(), courses.end(), [](const vector<int>& a, vector<int>& b) {             return a[1] < b[1];         }); ```  逻辑上用了priority_queue, 用于把每门课的长度push进去，自动排序，然后当长度不够的时候，把最长的那个从queue中pop出去，这时候也对day进行更新，以此来进行下去;  这里没有用滑动窗口，也没有取 max(a,b) , 题目类型不一样 。  "},{title:"707. Design Linked List",path:"/posts/707.%20Design%20Linked%20List%20.html",strippedContent:' \\707. Design Linked List  Medium  Design your implementation of the linked list. You can choose to use a singly or doubly linked list.  A node in a singly linked list should have two attributes: `val` and `next`. `val` is the value of the current node, and `next` is a pointer/reference to the next node.  If you want to use the doubly linked list, you will need one more attribute `prev` to indicate the previous node in the linked list. Assume all nodes in the linked list are **0-indexed**.  Implement the `MyLinkedList` class:  - `MyLinkedList()` Initializes the `MyLinkedList` object. - `int get(int index)` Get the value of the `indexth` node in the linked list. If the index is invalid, return `-1`. - `void addAtHead(int val)` Add a node of value `val` before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. - `void addAtTail(int val)` Append a node of value `val` as the last element of the linked list. - `void addAtIndex(int index, int val)` Add a node of value `val` before the `indexth` node in the linked list. If `index` equals the length of the linked list, the node will be appended to the end of the linked list. If `index` is greater than the length, the node **will not be inserted**. - `void deleteAtIndex(int index)` Delete the `indexth` node in the linked list, if the index is valid.     **Example 1:**  ``` Input ["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"] [[], [1], [3], [1, 2], [1], [1], [1]] Output [null, null, null, null, 2, null, 3]  Explanation MyLinkedList myLinkedList = new MyLinkedList(); myLinkedList.addAtHead(1); myLinkedList.addAtTail(3); myLinkedList.addAtIndex(1, 2);    // linked list becomes 1->2->3 myLinkedList.get(1);              // return 2 myLinkedList.deleteAtIndex(1);    // now the linked list is 1->3 myLinkedList.get(1);              // return 3 ```     **Constraints:**  - `0 <= index, val <= 1000` - Please do not use the built-in LinkedList library. - At most `2000` calls will be made to `get`, `addAtHead`, `addAtTail`, `addAtIndex` and `deleteAtIndex`.    ```cpp class MyLinkedList { public:   MyLinkedList(): head_(nullptr), tail_(nullptr), size_(0) {}      ~MyLinkedList() {  //析构函数，C++特殊的需要      Node* node = head_;     while (node) {       Node* cur = node;       node = node->next;       delete cur;     }     head_ = nullptr;     tail_ = nullptr;   }      int get(int index) {     if (index < 0 || index >= size_) return -1;     auto node = head_;     while (index--)       node = node->next;         return node->val;   }     void addAtHead(int val) {         head_ = new Node(val, head_);     if (size_++ == 0)       tail_ = head_;      }      void addAtTail(int val) {     auto node = new Node(val);     if (size_++ == 0) {       head_ = tail_ = node;     } else {           tail_->next = node;       tail_ = tail_->next;     }       }     void addAtIndex(int index, int val) {     if (index < 0 || index > size_) return;     if (index == 0) return addAtHead(val);     if (index == size_) return addAtTail(val);     Node dummy(0, head_);     Node* prev = &dummy;     while (index--) prev = prev->next;     prev->next = new Node(val, prev->next);         ++size_;   }     void deleteAtIndex(int index) {     if (index < 0 || index >= size_) return;     Node dummy(0, head_);     Node* prev = &dummy;     for (int i = 0; i < index; ++i)       prev = prev->next;     Node* node_to_delete = prev->next;     prev->next = prev->next->next;     if (index == 0) head_ = prev->next;     if (index == size_ - 1) tail_ = prev;     delete node_to_delete;     --size_;   } private:   struct Node {     int val;     Node* next;     Node(int _val): Node(_val, nullptr) {}     Node(int _val, Node* _next): val(_val), next(_next) {}   };   Node* head_;   Node* tail_;   int size_; };  /**  * Your MyLinkedList object will be instantiated and called as such:  * MyLinkedList* obj = new MyLinkedList();  * int param_1 = obj->get(index);  * obj->addAtHead(val);  * obj->addAtTail(val);  * obj->addAtIndex(index,val);  * obj->deleteAtIndex(index);  */ ```    '},{title:"713. Subarray Product Less Than K",path:"/posts/713.%20Subarray%20Product%20Less%20Than%20K.html",strippedContent:" ##713. Subarray Product Less Than K  Medium  Your are given an array of positive integers `nums`.  Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than `k`.  **Example 1:**  ``` Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]. Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k. ```    **Note:**  `0 < nums.length <= 50000`.  `0 < nums[i] < 1000`.  `0 <= k < 10^6`.    ```cpp class Solution { public:    int numSubarrayProductLessThanK(vector<int>& nums, int k) {         int left{}, cnt{}, runProd{1}, i{};         for (; i < nums.size(); i++) {             runProd *= nums[i];             while (runProd >= k && left <= i) { // Make sure left never passes right.                runProd /= nums[left++];             }             cnt += i - left + 1; // Captures numbers within the range that         } // otherwise would have been left out. For instance in 10, 5, 2, 6, two would         return cnt; // never have been counted individually.     } };   ```      这个题用了c++的一些特殊初始化方式，没见过。  这里补充一个blog：https://stephan14.github.io/2019/08/10/various-initialization-methods-for-C++/  一个知乎回答：https://www.zhihu.com/question/36735960    这个题 以例子为例十分巧妙：  > 1.  [10] > > 2. [5] ,[10,5] > > 3. [2], [5,2] > > 4. [6],[2,6],[5,2,6] > >      综上 可发现，它巧妙的通过计算cnt += i - left + 1，算出了当前可行的组合数。 由于是连续的，所以正好是这个i-left+1;  超过了的，直接通过runProd /= nums[left++]; 剔除掉最前面的数。      "},{title:"724. Find Pivot Index",path:"/posts/724.%20Find%20Pivot%20Index.html",strippedContent:' ##724. Find Pivot Index  Easy  Given an array of integers `nums`, write a method that returns the "pivot" index of this array.  We define the pivot index as the index where the sum of all the  numbers to the left of the index is equal to the sum of all the numbers  to the right of the index.  If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.     **Example 1:**  ``` Input: nums = [1,7,3,6,5,6] Output: 3 Explanation: The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3. Also, 3 is the first index where this occurs. ```  **Example 2:**  ``` Input: nums = [1,2,3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement. ```     **Constraints:**  - The length of `nums` will be in the range `[0, 10000]`. - Each element `nums[i]` will be an integer in the range `[-1000, 1000]`.    ```cpp // class Solution { // public: //     int pivotIndex(vector<int>& nums) { //         int n = nums.size(); //         vector<int> P; //         P[0] = nums[0]; //         vector<int> Q;          //         for (int i=1;i<n;i++){              //             P[i] = P[i-1]+ nums[i];              //         } //         for (int j =0;j<n;j++){ //             Q[j] = P[n-1]-P[j]-nums[j]; //         }          //         for (int e =1;e<n; e++) //             if (P[e]==Q[e]) //                 return e;              //          return -1;                   //     } // };  class Solution { public:     int pivotIndex(vector<int>& nums) {         const int sum = accumulate(nums.begin(), nums.end(), 0);         int l = 0;         int r = sum;         for (int i = 0; i < nums.size(); ++i) {             r -= nums[i];             if (l == r) return i;             l += nums[i];         }         return -1;     } }; ```  两点：  1.用for循环加值没办法解决左边和 与 右边和 一次解决的问题， 所以会超时；  2.注意该方法条件判断的位置，是给右边赋值的时候，此时左边还未加，恰好满足题目要求；'},{title:"763.Partition Labels",path:"/posts/763.Partition%20Labels.html",strippedContent:' 763. Partition Labels Medium  A string S of lowercase English letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.     Example 1:  Input: S = "ababcbacadefegdehijhklij" Output: [9,7,8] Explanation: The partition is "ababcbaca", "defegde", "hijhklij". This is a partition so that each letter appears in at most one part. A partition like "ababcbacadefegde", "hijhklij" is incorrect, because it splits S into less parts.     Note:      S will have length in range [1, 500].     S will consist of lowercase English letters (\'a\' to \'z\') only.   ```cpp class Solution { public:     vector<int> partitionLabels(string S) {         vector<int> m_(128,0);         for (int i=0;i<S.size();i++){             m_[S[i]] = i;                      }         vector<int> ans;         int start = 0;         int end = 0;         for (int i=0;i<S.size();i++){             end = max(end, m_[S[i]]);             if (i==end){                 ans.push_back(end-start+1);                 start = end +1;             }                      }                  return ans;              } }; ```    这个题关键在于hashtable，  我们将所有letter 构建 [letter] -> {最后出现序号i}的hashtable  然后max(end, i ) 就能知道这一组letter最后出现的位置;  依照这个去遍历 ，就能得到数组。'},{title:"732. My Calendar III_哈希",path:"/posts/732.%20My%20Calendar%20III_%E5%93%88%E5%B8%8C.html",strippedContent:' \\##732. My Calendar III  Hard  Implement a `MyCalendarThree` class to store your events. A new event can **always** be added.  Your class will have one method, `book(int start, int end)`. Formally, this represents a booking on the half open interval `[start, end)`, the range of real numbers `x` such that `start <= x < end`.  A *K-booking* happens when **K** events have some non-empty intersection (ie., there is some time that is common to all K events.)  For each call to the method `MyCalendar.book`, return an integer `K` representing the largest integer such that there exists a `K`-booking in the calendar.  Your class will be called like this: `MyCalendarThree cal = new MyCalendarThree();``MyCalendarThree.book(start, end)`  **Example 1:**  ``` MyCalendarThree(); MyCalendarThree.book(10, 20); // returns 1 MyCalendarThree.book(50, 60); // returns 1 MyCalendarThree.book(10, 40); // returns 2 MyCalendarThree.book(5, 15); // returns 3 MyCalendarThree.book(5, 10); // returns 3 MyCalendarThree.book(25, 55); // returns 3 Explanation:  The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking. The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking. The remaining events cause the maximum K-booking to be only a 3-booking. Note that the last event locally causes a 2-booking, but the answer is still 3 because eg. [10, 20), [10, 40), and [5, 15) are still triple booked. ```     **Note:**  - The number of calls to `MyCalendarThree.book` per test case will be at most `400`. - In calls to `MyCalendarThree.book(start, end)`, `start` and `end` are integers in the range `[0, 10^9]`.  ```cpp class MyCalendarThree {      public:      MyCalendarThree() {}     //std::map<int, int> deltas_;      int book(int start, int end) {         ++deltas_[start];         --deltas_[end];         int ans = 0;         int curr = 0;         for (const auto& kv : deltas_)                         ans = max(ans, curr += kv.second);         return ans;     } private:     std::map<int, int> deltas_;  };  int main(){     //string m = "ABABBBBB";     //string m = "5/3+1/3";     //int k  = 1;     //vector<vector<int>> m= {{1,3},{2,6},{8,10},{13,15}};     //vector<vector<int>> m= {{1,3},{0,3},{8,10},{13,15}};     //["MyCalendarThree","book","book","book","book","book","book"]     //[[],[10,20],[50,60],[10,40],[5,15],[5,10],[25,55]]     vector<vector<int>> m = {{10,20},{50,60},{10,40},{5,15},{5,10},{25,55}};     vector<int> param_1;     //vector<int> k= {4,4,1,5,1};      MyCalendarThree* obj = new MyCalendarThree();     for (auto it:m){          param_1.push_back(obj->book(it[0],it[1]));     }      //vector<int> m= {3,3,4};     //vector<int> k = {3,4,4};         // Solution s;     // vector<vector<int>> result = s.book(m);      for(auto it:param_1)             cout<<"result is: "<<it<<endl;      return 0; }   ```    这个题就是数边界，bounderies counting，关键就这一句    ​\tfor (const auto& kv : deltas_)             ​            ans = max(ans, curr += kv.second);'},{title:"792. Number of Matching Subsequences_哈希",path:"/posts/792.%20Number%20of%20Matching%20Subsequences_%E5%93%88%E5%B8%8C.html",strippedContent:' \\##792. Number of Matching Subsequences  Medium  Given string `S` and a dictionary of words `words`, find the number of `words[i]` that is a subsequence of `S`.  ``` Example : Input:  S = "abcde" words = ["a", "bb", "acd", "ace"] Output: 3 Explanation: There are three words in words that are a subsequence of S: "a", "acd", "ace". ```  **Note:**  - All words in `words` and `S` will only consists of lowercase letters. - The length of `S` will be in the range of `[1, 50000]`. - The length of `words` will be in the range of `[1, 5000]`. - The length of `words[i]` will be in the range of `[1, 50]`.    ```cpp class Solution { public:     int numMatchingSubseq(string S, vector<string>& words) {         vector<vector<int>> pos(128);         int count = 0;         for (int i =0; i<S.length();i++){             pos[S[i]].push_back(i);         }         for (auto word:words){             if (ismatch(word,pos))                 count++;                      }         return count;              } private:     unordered_map<string,bool> m_;     bool ismatch(const string& word,const vector<vector<int>>& pos){         if(m_.count(word)) return m_[word];         int last_index = -1;         for (auto c:word){             const vector<int>& p =pos[c];             const auto it =std::lower_bound(p.begin(),p.end(),last_index+1);             if(it == p.end()) return m_[word] = false;             last_index = *it;         }         return m_[word] = true;                       } }; ```    这个题首先把 string S 遍历做成存着index的二位数组（字典）;  然后每次调用ismatch()函数去看word 能不能把字典里的index 都耗尽;  耗尽了说明 word里的该字母 出现次数比S要多 ;  没耗尽说明它是一个 subsequence。  另外，string有length();  vector<int> 只能size;'},{title:"815. Bus Routes_BFS",path:"/posts/815.%20Bus%20Routes_BFS.html",strippedContent:" \\##815. Bus Routes  Hard  We have a list of bus routes. Each `routes[i]` is a bus route that the i-th bus repeats forever. For example if `routes[0] = [1, 5, 7]`, this means that the first bus (0-th indexed) travels in the sequence 1->5->7->1->5->7->1->... forever.  We start at bus stop `S` (initially not on a bus), and we want to go to bus stop `T`. Travelling by buses only, what is the least number of buses we must  take to reach our destination? Return -1 if it is not possible.  ``` Example: Input:  routes = [[1, 2, 7], [3, 6, 7]] S = 1 T = 6 Output: 2 Explanation:  The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6. ```     **Constraints:**  - `1 <= routes.length <= 500`. - `1 <= routes[i].length <= 10^5`. - `0 <= routes[i][j] < 10 ^ 6`.        ![img](http://zxi.mytechroad.com/blog/wp-content/uploads/2018/04/815-ep180.png)  ```cpp class Solution { public:   int numBusesToDestination(vector<vector<int>>& routes, int S, int T) {     if (S == T) return 0;          unordered_map<int, vector<int>> m;   //构造 stop->{bus} hashmap     for (int i = 0; i < routes.size(); ++i)       for (const int stop : routes[i])         m[stop].push_back(i);          vector<int> visited(routes.size(), 0); //构造一个一维数组，用来标记线路是否被访问，也是一种hashmap， 由于 `0 <= routes[i][j] < 10 ^ 6`，用一维数组标记会节省开销;       queue<int> q;       q.push(S);     int buses = 0;          while (!q.empty()) {       int size = q.size();             ++buses;       while (size--) {         int curr = q.front(); q.pop();                 for (const int bus : m[curr]) {           if (visited[bus]) continue;                      visited[bus] = 1;  //标记该路线已访问;           for (int stop : routes[bus]) {             if (stop == T) return buses;   //如果找到车站，返回访问过公交路线的数量;                      q.push(stop); //没找到车站， 就把该车站加入队列;           }         }               }           }     return -1;   } }; ```    BFS拓展，    "},{title:"890. Find and Replace Pattern",path:"/posts/890.%20Find%20and%20Replace%20Pattern.html",strippedContent:' ##890. Find and Replace Pattern  Medium  You have a list of `words` and a `pattern`, and you want to know which words in `words` matches the pattern.  A word matches the pattern if there exists a permutation of letters `p` so that after replacing every letter `x` in the pattern with `p(x)`, we get the desired word.  (*Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.*)  Return a list of the words in `words` that match the given pattern.   You may return the answer in any order.     **Example 1:**  ``` Input: words = ["abc","deq","mee","aqq","dkd","ccc"], pattern = "abb" Output: ["mee","aqq"] Explanation: "mee" matches the pattern because there is a permutation {a -> m, b -> e, ...}.  "ccc" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter. ```     **Note:**  - `1 <= words.length <= 50` - `1 <= pattern.length = words[i].length <= 20`    ```cpp // Author: Huahua // Running time: 0 ms class Solution { public:   vector<string> findAndReplacePattern(vector<string>& words, string pattern) {         vector<string> ans;     for (const string& w : words)       if (match(w, pattern)) ans.push_back(w);     return ans;   } private:   bool match(const string& w, const string& p) {     vector<int> last_pos_w(128, INT_MIN); // last pos of x in w     vector<int> last_pos_p(128, INT_MIN); // last pos of x in p     for (int i = 0; i < w.size(); ++i)       if (last_pos_w[w[i]] != last_pos_p[p[i]]) {         return false;       } else {         last_pos_w[w[i]] = last_pos_p[p[i]] = i;       }     return true;   } }; ```       这个题巧妙的地方在于： 创建了两个新的128位长的值为负无穷的数组，用来作为标记该位是否有被访问的标志位。 这是一个数组标志位，从而实现了字符串 对位 关联 的功能。   通过对位比较， 也就实现了题目所要求的 元素双射 关系。'},{title:"902. Numbers At Most N Given Digit Set",path:"/posts/902.%20Numbers%20At%20Most%20N%20Given%20Digit%20Set.html",strippedContent:" \\##902. Numbers At Most N Given Digit Set  Hard  Given an array of `digits`, you can write numbers using each `digits[i]` as many times as we want. For example, if `digits = ['1','3','5']`, we may write numbers such as `'13'`, `'551'`, and `'1351315'`.  Return *the number of positive integers that can be generated* that are less than or equal to a given integer `n`.     **Example 1:**  ``` Input: digits = [\"1\",\"3\",\"5\",\"7\"], n = 100 Output: 20 Explanation:  The 20 numbers that can be written are: 1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77. ```  **Example 2:**  ``` Input: digits = [\"1\",\"4\",\"9\"], n = 1000000000 Output: 29523 Explanation:  We can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers, 81 four digit numbers, 243 five digit numbers, 729 six digit numbers, 2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers. In total, this is 29523 integers that can be written using the digits array. ```  **Example 3:**  ``` Input: digits = [\"7\"], n = 8 Output: 1 ```     **Constraints:**  - `1 <= digits.length <= 9` - `digits[i].length == 1` - `digits[i]` is a digit from `'1'` to `'9'`. - All the values in `digits` are **unique**. - `1 <= n <= 109`      ```cpp class Solution {     int count = 0;     string num;     int K;      public:     int atMostNGivenDigitSet(vector<string>& D, int N)      {         num = to_string(N);         K = num.size();                  for (int i=1; i<=K-1; i++)             count += pow(D.size(), i);  //这里计算的是前 K-1 位 所有的可能的和                  DFS(0, 0, D);                  return count;     }          void DFS(long cur, int pos, vector<string>& D)     {         if (pos==K)         {             count+=1;             return;         }                  for (string s: D)         {             if ('0'+stoi(s) < num[pos])  // '0'+ 可以让整形， 变字符型                 count += pow( D.size(), K-1-pos);  //这里count 是在前面基础上累加，算的是第k位的数， 与D 进行比对 然后计数；             else if ('0'+stoi(s) == num[pos])                 DFS(cur*10+stoi(s), pos+1, D); //这里对cur进行移位比对                  }                    } }; ```      "},{title:"904. Fruit Into Baskets_移动窗口+哈希表",path:"/posts/904.%20Fruit%20Into%20Baskets_%E7%A7%BB%E5%8A%A8%E7%AA%97%E5%8F%A3+%E5%93%88%E5%B8%8C%E8%A1%A8.html",strippedContent:" \\##904. Fruit Into Baskets  Medium  In a row of trees, the `i`-th tree produces fruit with type `tree[i]`.  You **start at any tree of your choice**, then repeatedly perform the following steps:  1. Add one piece of fruit from this tree to your baskets. If you cannot, stop. 2. Move to the next tree to the right of the current tree. If there is no tree to the right, stop.  Note that you do not have any choice after the initial choice of  starting tree: you must perform step 1, then step 2, then back to step  1, then step 2, and so on until you stop.  You have two baskets, and each basket can carry any quantity of  fruit, but you want each basket to only carry one type of fruit each.  What is the total amount of fruit you can collect with this procedure?     **Example 1:**  ``` Input: [1,2,1] Output: 3 Explanation: We can collect [1,2,1]. ```  **Example 2:**  ``` Input: [0,1,2,2] Output: 3 Explanation: We can collect [1,2,2]. If we started at the first tree, we would only collect [0, 1]. ```  **Example 3:**  ``` Input: [1,2,3,2,2] Output: 4 Explanation: We can collect [2,3,2,2]. If we started at the first tree, we would only collect [1, 2]. ```  **Example 4:**  ``` Input: [3,3,3,1,2,1,1,2,3,3,4] Output: 5 Explanation: We can collect [1,2,1,1,2]. If we started at the first tree or the eighth tree, we would only collect 4 fruits. ```     **Note:**  1. `1 <= tree.length <= 40000` 2. `0 <= tree[i] < tree.length`  ```cpp class Solution { public: int totalFruit(vector<int>& tree) { \tunordered_map<int, int> m; \tint minval = 0, maxsize = 0, index = 0;  \tfor(auto it : tree){ \t\tif(!m.count(it) and m.size() == 2){//这里条件是遇到hashmap没有存的，且此时hashmap的长度是2; \t\t\tint val, pos = INT_MAX; \t\t\tfor(auto i : m){ // only 2 times that is constant \t\t\t\tif(i.second < pos)//这里需要对index进行比较，找出小的那个 \t\t\t\t\tpos = i.second, val = i.first; \t\t\t} \t\t\tm.erase(val);  //hashmap删除index较小的那个数， \t\t\tminval = pos + 1;//窗口右移动 \t\t} \t\tm[it] = index; //将it的index添加到hashmap; \t\tmaxsize = max(maxsize, index - minval + 1); \t\tindex++;// index是窗口的右边框，minival是窗口的左边框; \t} \treturn maxsize; }  }; ```      这个题属于 典型的 移动窗口 + hashmap的题目;  "},{title:"28. 实现 strStr()_KMP",path:"/posts/28.%20%E5%AE%9E%E7%8E%B0%20strStr()_KMP.html",strippedContent:' /#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)  实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。  给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 **-1**。  **示例 1:**  ``` 输入: haystack = "hello", needle = "ll" 输出: 2 ```  **示例 2:**  ``` 输入: haystack = "aaaaa", needle = "bba" 输出: -1 ```  **说明:**  当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。  对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。      ```cpp   namespace KMP {     vector<int> Build(const string& p) {     const int m = p.length();     vector<int> nxt{0, 0};     for (int i = 1, j = 0; i < m; ++i) {         while (j > 0 && p[i] != p[j])         j = nxt[j];         if (p[i] == p[j])         ++j;         nxt.push_back(j);     }     return nxt;     } vector<int> Match(const string& s, const string& p) {   vector<int> nxt(Build(p));   vector<int> ans;   const int n = s.length();   const int m = p.length();   for (int i = 0, j = 0; i < n; ++i) {     while (j > 0 && s[i] != p[j])       j = nxt[j];     if (s[i] == p[j])       ++j;     if (j == m) {       ans.push_back(i - m + 1);       j = nxt[j];     }    }   return ans; } }  // namespace KMP   class Solution { public:     int strStr(string haystack, string needle) {           if (needle.empty()) return 0;           auto matches = KMP::Match(haystack,needle);           return matches.empty()? -1 :matches[0];      }  };  ```    这个题是KMP算法的应用，也可以用bruteforce去做。   '}]}}]);